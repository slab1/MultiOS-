"""
PXE Boot Installation Server for Network-based MultiOS Deployment
"""

import os
import sys
import logging
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime
import json

from ..core.models import SystemInfo, SiteConfig
from ..core.utils import generate_system_id, calculate_md5, execute_command

class PXEServer:
    """PXE boot server for network-based installations"""
    
    def __init__(self, config_path: str = "/etc/multios-enterprise/pxe.yaml"):
        self.config_path = config_path
        self.logger = logging.getLogger(__name__)
        self.sites = {}
        self.boot_images = {}
        self.install_profiles = {}
        
        # PXE configuration directories
        self.pxe_root = Path("/var/lib/tftpboot")
        self.pxe_config_dir = self.pxe_root / "pxelinux.cfg"
        self.images_dir = self.pxe_root / "images"
        self.kernels_dir = self.pxe_root / "kernels"
        
        self._setup_directories()
        self._load_configuration()
        self._setup_services()
    
    def _setup_directories(self) -> None:
        """Create PXE server directories"""
        directories = [
            self.pxe_root,
            self.pxe_config_dir,
            self.images_dir,
            self.kernels_dir,
            self.pxe_root / "multios" / "kernels",
            self.pxe_root / "multios" / "initrd",
            self.pxe_root / "multios" / "install"
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
            
        self.logger.info(f"Created PXE directories at {self.pxe_root}")
    
    def _load_configuration(self) -> None:
        """Load PXE server configuration"""
        if not os.path.exists(self.config_path):
            self._create_default_config()
    
    def _create_default_config(self) -> None:
        """Create default PXE configuration"""
        default_config = {
            'dhcp_enabled': True,
            'dhcp_range': '192.168.1.100-192.168.1.200',
            'dhcp_lease_time': '7200',
            'boot_filename': 'pxelinux.0',
            'next_server': '',
            'boot_images': {},
            'install_profiles': {}
        }
        
        with open(self.config_path, 'w') as f:
            json.dump(default_config, f, indent=2)
    
    def _setup_services(self) -> None:
        """Setup PXE-related services"""
        # Install required packages
        required_packages = [
            'isc-dhcp-server',
            'tftpd-hpa',
            'syslinux',
            'xinetd'
        ]
        
        for package in required_packages:
            try:
                execute_command(['apt', 'install', '-y', package])
                self.logger.info(f"Installed {package}")
            except Exception as e:
                self.logger.warning(f"Failed to install {package}: {e}")
        
        # Configure DHCP server
        self._configure_dhcp_server()
        
        # Configure TFTP server
        self._configure_tftp_server()
    
    def _configure_dhcp_server(self) -> None:
        """Configure DHCP server for PXE boot"""
        dhcp_config = """
# DHCP Configuration for MultiOS PXE Boot
# Generated by MultiOS Enterprise Deployment System

default-lease-time 7200;
max-lease-time 43200;
authoritative;

# PXE boot configuration
allow booting;
allow bootp;

# Network configuration
option domain-name "multios.local";
option domain-name-servers 8.8.8.8, 8.8.4.4;
option routers 192.168.1.1;

# PXE server settings
next-server 192.168.1.1;
filename "pxelinux.0";

# Boot images mapping
class "multios-desktop" {
    match if substring(option vendor-class-identifier, 0, 20) = "MultiOS Desktop";
    filename "multios/multios-desktop.bin";
}

class "multios-laptop" {
    match if substring(option vendor-class-identifier, 0, 19) = "MultiOS Laptop";
    filename "multios/multios-laptop.bin";
}

class "multios-tablet" {
    match if substring(option vendor-class-identifier, 0, 18) = "MultiOS Tablet";
    filename "multios/multios-tablet.bin";
}

class "multios-server" {
    match if substring(option vendor-class-identifier, 0, 19) = "MultiOS Server";
    filename "multios/multios-server.bin";
}

# Subnet configuration
subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.100 192.168.1.200;
    option broadcast-address 192.168.1.255;
}

# Static reservations for known systems
# Add static reservations as needed:
# host desktop-001 {
#     hardware ethernet aa:bb:cc:dd:ee:ff;
#     fixed-address 192.168.1.10;
#     filename "multios/multios-desktop.bin";
# }
"""
        
        dhcp_config_path = "/etc/dhcp/dhcpd.conf"
        try:
            with open(dhcp_config_path, 'w') as f:
                f.write(dhcp_config)
            self.logger.info(f"DHCP configuration written to {dhcp_config_path}")
        except Exception as e:
            self.logger.error(f"Failed to write DHCP configuration: {e}")
    
    def _configure_tftp_server(self) -> None:
        """Configure TFTP server for PXE boot"""
        tftp_config = """
# TFTP Server Configuration for MultiOS PXE Boot
# Generated by MultiOS Enterprise Deployment System

service tftp
{
    socket_type = dgram
    protocol = udp
    wait = yes
    user = root
    server = /usr/sbin/in.tftpd
    server_args = -s /var/lib/tftpboot -v
    disable = no
    per_source = 11
    cps = 100 2
    flags = IPv4
}
"""
        
        xinetd_config_path = "/etc/xinetd.d/tftp"
        try:
            with open(xinetd_config_path, 'w') as f:
                f.write(tftp_config)
            self.logger.info(f"TFTP configuration written to {xinetd_config_path}")
        except Exception as e:
            self.logger.error(f"Failed to write TFTP configuration: {e}")
    
    def add_site(self, site_config: SiteConfig) -> bool:
        """Add a new site to PXE server"""
        try:
            self.sites[site_config.site_id] = site_config
            
            # Create site-specific directory structure
            site_dir = self.pxe_root / "sites" / site_config.site_id
            site_dir.mkdir(parents=True, exist_ok=True)
            
            # Update DHCP configuration for site
            self._update_site_dhcp_config(site_config)
            
            self.logger.info(f"Added site {site_config.name} to PXE server")
            return True
        except Exception as e:
            self.logger.error(f"Failed to add site to PXE server: {e}")
            return False
    
    def _update_site_dhcp_config(self, site: SiteConfig) -> None:
        """Update DHCP configuration for a specific site"""
        site_config = f"""
# Site-specific configuration for {site.name}
subnet {site.network_range} netmask 255.255.255.0 {{
    range {site.dhcp_range};
    option broadcast-address {self._calculate_broadcast(site.network_range)};
    option domain-name-servers {' '.join(site.dns_servers)};
    next-server {self._get_local_ip()};
    filename "multios/multios-default.bin";
}}
"""
        
        site_dhcp_file = self.pxe_root / "sites" / site.site_id / "dhcp.conf"
        try:
            with open(site_dhcp_file, 'w') as f:
                f.write(site_config)
        except Exception as e:
            self.logger.error(f"Failed to write site DHCP config: {e}")
    
    def _calculate_broadcast(self, network_range: str) -> str:
        """Calculate broadcast address for network range"""
        try:
            import ipaddress
            network = ipaddress.IPv4Network(network_range, strict=False)
            return str(network.broadcast_address)
        except Exception:
            return "255.255.255.255"
    
    def _get_local_ip(self) -> str:
        """Get local IP address for this server"""
        try:
            import socket
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except Exception:
            return "127.0.0.1"
    
    def add_boot_image(self, image_name: str, kernel_path: str, initrd_path: str, 
                      boot_config: Dict[str, str]) -> bool:
        """Add a boot image to PXE server"""
        try:
            # Copy kernel and initrd to PXE directory
            kernel_dest = self.kernels_dir / f"{image_name}.kernel"
            initrd_dest = self.kernels_dir / f"{image_name}.initrd"
            
            shutil.copy2(kernel_path, kernel_dest)
            shutil.copy2(initrd_path, initrd_dest)
            
            # Calculate checksums
            kernel_md5 = calculate_md5(kernel_path)
            initrd_md5 = calculate_md5(initrd_path)
            
            # Store image metadata
            self.boot_images[image_name] = {
                'kernel_path': str(kernel_dest),
                'initrd_path': str(initrd_dest),
                'kernel_md5': kernel_md5,
                'initrd_md5': initrd_md5,
                'boot_config': boot_config,
                'created': datetime.now().isoformat()
            }
            
            # Create PXE configuration file
            self._create_pxe_config(image_name, boot_config)
            
            self.logger.info(f"Added boot image {image_name} to PXE server")
            return True
        except Exception as e:
            self.logger.error(f"Failed to add boot image {image_name}: {e}")
            return False
    
    def _create_pxe_config(self, image_name: str, boot_config: Dict[str, str]) -> None:
        """Create PXE configuration file for boot image"""
        config_content = f"""
# PXE Configuration for {image_name}
# Generated by MultiOS Enterprise Deployment System

DEFAULT multios-{image_name}
PROMPT 1
TIMEOUT 30

LABEL multios-{image_name}
    KERNEL kernels/{image_name}.kernel
    APPEND initrd=kernels/{image_name}.initrd {boot_config.get('kernel_params', '')}
    
    # Additional boot options
    IPAPPEND 1
    
LABEL rescue
    KERNEL kernels/rescue.kernel
    APPEND initrd=kernels/rescue.initrd rescue
    
LABEL local
    LOCALBOOT 0
"""
        
        config_file = self.pxe_config_dir / f"01-{image_name.replace('_', '-')}"
        try:
            with open(config_file, 'w') as f:
                f.write(config_content)
        except Exception as e:
            self.logger.error(f"Failed to create PXE config for {image_name}: {e}")
    
    def install_os(self, system: SystemInfo, os_version: str, 
                   installation_options: Optional[Dict[str, Any]] = None) -> bool:
        """Install OS to a system via PXE boot"""
        try:
            installation_options = installation_options or {}
            
            # Get installation profile for system type
            profile_key = f"multios-{system.system_type.value}"
            if profile_key not in self.boot_images:
                self.logger.error(f"No boot image found for system type {system.system_type}")
                return False
            
            # Create installation task
            install_task = {
                'task_id': generate_system_id(),
                'system_id': system.system_id,
                'system_mac': system.mac_address,
                'system_ip': system.ip_address,
                'os_version': os_version,
                'boot_image': profile_key,
                'installation_options': installation_options,
                'status': 'pending',
                'created': datetime.now().isoformat()
            }
            
            # Queue installation task
            self._queue_installation_task(install_task)
            
            # Configure DHCP reservation for this system
            self._configure_system_dhcp(system)
            
            self.logger.info(f"Queued installation of {os_version} for system {system.hostname}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to install OS on {system.hostname}: {e}")
            return False
    
    def _queue_installation_task(self, task: Dict[str, Any]) -> None:
        """Queue an installation task"""
        task_file = self.pxe_root / "tasks" / f"{task['task_id']}.json"
        task_file.parent.mkdir(exist_ok=True)
        
        try:
            with open(task_file, 'w') as f:
                json.dump(task, f, indent=2)
            self.logger.info(f"Queued installation task {task['task_id']}")
        except Exception as e:
            self.logger.error(f"Failed to queue installation task: {e}")
    
    def _configure_system_dhcp(self, system: SystemInfo) -> None:
        """Configure DHCP reservation for specific system"""
        system_config = f"""
host {system.hostname.lower()} {{
    hardware ethernet {system.mac_address};
    fixed-address {system.ip_address};
    filename "multios/multios-{system.system_type.value}.bin";
    next-server {self._get_local_ip()};
}}
"""
        
        dhcp_config_path = "/etc/dhcp/dhcpd.conf"
        try:
            # Add system reservation to DHCP config
            with open(dhcp_config_path, 'a') as f:
                f.write(system_config)
            
            self.logger.info(f"Added DHCP reservation for {system.hostname}")
        except Exception as e:
            self.logger.error(f"Failed to configure DHCP for {system.hostname}: {e}")
    
    def create_install_profile(self, profile_name: str, profile_config: Dict[str, Any]) -> bool:
        """Create an installation profile"""
        try:
            # Validate profile configuration
            required_fields = ['kernel_path', 'initrd_path', 'boot_config']
            for field in required_fields:
                if field not in profile_config:
                    raise ValueError(f"Missing required field: {field}")
            
            # Create boot image
            success = self.add_boot_image(
                profile_name,
                profile_config['kernel_path'],
                profile_config['initrd_path'],
                profile_config['boot_config']
            )
            
            if success:
                self.install_profiles[profile_name] = profile_config
                self.logger.info(f"Created installation profile {profile_name}")
            
            return success
        except Exception as e:
            self.logger.error(f"Failed to create installation profile {profile_name}: {e}")
            return False
    
    def start_services(self) -> bool:
        """Start PXE server services"""
        try:
            # Start DHCP server
            result, stdout, stderr = execute_command(['systemctl', 'start', 'isc-dhcp-server'])
            if result == 0:
                self.logger.info("DHCP server started successfully")
            else:
                self.logger.error(f"Failed to start DHCP server: {stderr}")
            
            # Start TFTP server
            result, stdout, stderr = execute_command(['systemctl', 'restart', 'xinetd'])
            if result == 0:
                self.logger.info("TFTP server started successfully")
            else:
                self.logger.error(f"Failed to start TFTP server: {stderr}")
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to start PXE services: {e}")
            return False
    
    def stop_services(self) -> bool:
        """Stop PXE server services"""
        try:
            execute_command(['systemctl', 'stop', 'isc-dhcp-server'])
            execute_command(['systemctl', 'stop', 'xinetd'])
            self.logger.info("PXE services stopped")
            return True
        except Exception as e:
            self.logger.error(f"Failed to stop PXE services: {e}")
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get PXE server status"""
        return {
            'running': self._is_service_running(),
            'sites': len(self.sites),
            'boot_images': len(self.boot_images),
            'installation_profiles': len(self.install_profiles),
            'pending_tasks': self._count_pending_tasks()
        }
    
    def _is_service_running(self) -> bool:
        """Check if PXE services are running"""
        try:
            result, _, _ = execute_command(['systemctl', 'is-active', 'isc-dhcp-server'])
            return result == 0
        except Exception:
            return False
    
    def _count_pending_tasks(self) -> int:
        """Count pending installation tasks"""
        try:
            tasks_dir = self.pxe_root / "tasks"
            if not tasks_dir.exists():
                return 0
            return len(list(tasks_dir.glob("*.json")))
        except Exception:
            return 0
    
    def cleanup_old_tasks(self, days: int = 30) -> None:
        """Clean up old installation tasks"""
        try:
            tasks_dir = self.pxe_root / "tasks"
            if not tasks_dir.exists():
                return
            
            cutoff_date = datetime.now().timestamp() - (days * 24 * 3600)
            
            for task_file in tasks_dir.glob("*.json"):
                if task_file.stat().st_mtime < cutoff_date:
                    task_file.unlink()
                    self.logger.info(f"Cleaned up old task file: {task_file}")
        except Exception as e:
            self.logger.error(f"Failed to cleanup old tasks: {e}")
