{"origin_pdf_path": "https://www.usenix.org/system/files/osdi20-boos.pdf", "text_in_pdf": "Theseus: an Experiment in Operating System Structure and State Management  \n\nKevin Boos, Rice University; Namitha Liyanage, Yale University; Ramla Ijaz, Rice University; Lin Zhong, Yale University https://www.usenix.org/conference/osdi20/presentation/boos  \n\nThis paper is included in the Proceedings of the 14th USENIX Symposium on Operating Systems Design and Implementation  \n\nNovember 4–6, 2020 978-1-939133-19-9  \n\nOpen access to the Proceedings of the 14th USENIX Symposium on Operating Systems Design and Implementation is sponsored by USENIX  \n\nTheseus: an Experiment in Operating System Structure and State Management  \n\nKevin Boos Namitha Liyanage Ramla Ijaz Lin Zhong Rice University Yale University Rice University Yale University  \n\nAbstract  \n\nThis paper describes an operating system (OS) called Theseus. Theseus is the result of multi-year experimentation to redesign and improve OS modularity by reducing the states one component holds for another, and to leverage a safe programming language, namely Rust, to shift as many OS responsibilities as possible to the compiler.  \n\nTheseus embodies two primary contributions. First, an OS structure in which many tiny components with clearly-defined, runtime-persistent bounds interact without holding states for each other. Second, an intralingual approach that realizes the OS itself using language-level mechanisms such that the compiler can enforce invariants about OS semantics.  \n\nTheseus’s structure, intralingual design, and state management realize live evolution and fault recovery for core OS components in ways beyond that of existing works.  \n\n1 Introduction  \n\nWe report an experimentation of OS structural design, state management, and implementation techniques that leverage the power of modern safe systems programming languages, namely Rust. This endeavor was initially motivated by studies of state spill [16]: one software component harboring changed states as a result of handling an interaction from another component, such that their future correctness depends on said states. Prevalent in modern systems software, state spill leads to fate sharing between otherwise modularized and isolated components and thus hinders the realization of desirable computing goals such as evolvability and availability. For example, state spill in Android system services causes the entire userspace frameworks to crash upon a system service failure, losing the states and progress of all applications, even those not using the failed service [16]. Reliable microkernels further attest that management of states spilled into OS services is a barrier to fault tolerance [21] and live update [28].  \n\nEvolvability and availability of systems software are crucial in environments where reliability is necessary yet hardware redundancy is expensive or impossible. For example, systems software updates must be painstakingly applied without downtime or lost execution context in pacemakers [26] and space probes [25, 62]. Even in datacenters, where network switches are replicated for reliability, switch software failures and maintenance updates still lead to network outages [27,48].  \n\nOn the quest to determine to what extent state spill can be avoided in OS code, we chose to write an OS from scratch. We were drawn to Rust because its ownership model provides a convenient mechanism for implementing isolation and zero-cost state transfer between OS components. Our initial OS-building experience led to two important realizations. First, mitigating state spill, or better state management in general, necessitates a rethinking of OS structure because state spill (by definition) depends on how the OS is modularized. Second, modern systems programming languages like Rust can be used not just to write safe OS code but also to statically ensure certain correctness invariants for OS behaviors.  \n\nThe outcome of our experimentation is Theseus OS, which makes two contributions to systems software design and implementation. First, Theseus has a novel OS structure of many tiny components with clearly-defined, runtime-persistent bounds. The system maintains metadata about and tracks interdependencies between components, which facilitates live evolution and fault recovery of these components (§3).  \n\nSecond, and more importantly, Theseus contributes the intralingual OS design approach, which entails matching the OS’s execution environment to the runtime model of its implementation language and implementing the OS itself using language-level mechanisms. Through intralingual design, Theseus empowers the compiler to apply its safety checks to OS code with no gaps in its understanding of code behavior, and shifts semantic errors from runtime failures into compile-time errors, both to a greater degree than existing OSes. Intralingual design goes beyond safety, enabling the compiler to statically check OS semantic invariants and assume resource bookkeeping duties. This is elaborated in $\\S4$ .  \n\nTheseus’s structure and intralingual design naturally reduce states the OS must maintain, reducing state spill between its components. We describe Theseus’s state management techniques to further mitigate the effects of state spill in $\\S5$ .  \n\nTo demonstrate the utility of Theseus’s design, we implement live evolution and fault recovery (for availability) within it (§6). With this, we posit that Theseus is well-suited for highend embedded systems and datacenter components, where availability is needed in the absence of or in addition to hardware redundancy. Therein, Theseus’s limitations of being a new OS and needing safe-language programs have a lesser impact, as applications can be co-developed with the OS in an environment under a single operator’s control.  \n\nWe evaluate how well Theseus achieves these goals in $\\S7$ . Through a set of case studies, we show that Theseus can easily and arbitrarily live evolve core system components in ways beyond prior live update works, e.g., joint application-kernel evolution, or evolution of microkernel-level components. As Theseus can gracefully handle language-level faults (panics in Rust), we demonstrate Theseus’s ability to tolerate more challenging transient hardware faults that manifest in the OS core. To this end, we present a study of fault manifestation and recovery in Theseus and a comparison with MINIX 3 of fault recovery for components that necessarily exist inside the microkernel. Although performance is not a primary goal of Theseus, we find that its intralingual and spill-free designs do not impose a glaring performance penalty, but that the impact varies across subsystems.  \n\nTheseus is currently implemented on $\\mathbf{X}86\\_64$ with support for most hardware features, such as multicore processing, preemptive multitasking, SIMD extensions, basic networking and disk I/O, and graphical displays. It represents roughly four person-years of effort and comprises $\\mathord{\\sim}38000$ lines of from-scratch Rust code, 900 lines of bootstrap assembly code, 246 crates of which 176 are first-party, and 72 unsafe code blocks or statements across 21 crates, most of which are for port I/O or special register access.  \n\nHowever, Theseus is far less complete than commercial systems, or experimental ones such as Singularity [33] and Barrelfish [8] that have undergone substantially more development. For example, Theseus currently lacks POSIX support and a full standard library. Thus, we do not make claims about certain OS aspects, e.g., efficiency or security; this paper focuses on Theseus’s structure and intralingual design and the ensuing benefits for live evolution and fault recovery.  \n\nTheseus’s code and documentation are open-source [61].  \n\n2 Rust Language Background  \n\nThe Rust programming language [40] is designed to provide strong type and memory safety guarantees at compile time, combining the power and expressiveness of a high-level managed language with the C-like efficiency of no garbage collection or underlying runtime. Theseus leverages many Rust features to realize an intralingual, safe OS design and employs the crate, Rust’s project container and translation unit, for source-level modularity. A crate contains source code and a dependency manifest. Theseus does not use Rust’s standard library but does use its fundamental core and alloc libraries.  \n\nRust’s ownership model is the key to its compile-time memory safety and management. Ownership is based on affine types, in which a value can be used at most once. In Rust, every value has an owner, e.g., the string value \"hello!\" allocated in L4 below is owned by the hello variable. After a value is moved, e.g., if \"hello!\" was moved in L5 from hello to owned_string (L14), its ownership would be transferred and the previous owner (hello) could no longer use it.  \n\n1 fn main() {   \n2 let hel: &str;   \n3 {   \n4 let hello $=$ String::from(\"hello!\");   \n5 // consume(hello); // $\\longrightarrow$ \"value moved\" error in L6   \n6 let borrowed_str: &str $=$ &hello;   \n7 hel $=$ substr(borrowed_str);   \n8 }   \n9 // print!(\"{}\", hel); $//\\longrightarrow$ lifetime error   \n10 }   \n11 fn substr(input_str: &'a str) $->\\;\\&\\,^{\\prime}\\,\\ a$ str {   \n12 &input_str[0..3] // return value has lifetime 'a   \n13 }   \n14 fn consume(owned_string: String) {...}  \n\nWhen the owner’s scope ends, e.g., at the end of a lexical block, the owned value is dropped (released) by virtue of the compiler inserting a call to its destructor. Destructors in Rust are realized by implementing the Drop trait for a given type, in which a custom drop handler can perform arbitrary actions beyond freeing memory. On L8 above, the hello string falls out of scope and is auto-deallocated by its drop handler.  \n\nValues can also be borrowed to obtain references to them (L6), and the lifetime of those references cannot outlast the lifetime of the owned value. The syntax in L11 gives the name 'a to the lifetime of the input_str argument, and specifies that the returned &str reference has that same lifetime 'a. That returned &str reference is assigned to hel in L7, which would result in a lifetime violation in L9 because hel would be used after the owned value it was originally borrowed from (hello) was dropped in L8. Rust’s compiler includes a borrow checker to enforce these lifetime rules, as well as the core tenet of aliasing XOR mutability, in which there can be multiple immutable references or a single mutable reference to a value, but not both at once. This allows it to statically ensure memory safety for values on the stack and heap.  \n\nTheseus also extensively leverages Rust traits, a declaration of an abstract type that specifies the set of methods the type must implement, similar to polymorphic interfaces in OOP languages. Traits can be used to place bounds on generic type parameters. For example, the function fn print_str>(s: T){ } uses the underlined trait bound to specify that its argument named s must be of any abstract type T that can be converted into a String.  \n\n3 Theseus Overview and Design Principles  \n\nThe overall design of Theseus specifies a system architecture consisting of many small distinct components, called cells, which can be composed and interchanged at runtime. A cell is a software-defined unit of modularity that serves as the core building block of the OS, much like their namesake of biological cells in an organism (no relation to Rust’s std::cell). Theseus enables all software written in safe Rust, including applications and libraries, to coexist alongside the core OS components in a single address space (SAS) and execute at a single privilege level (SPL), building upon language-provided type and memory safety to realize isolation instead of hardware protection. Everything presented herein is written in Rust and runs in the SAS/SPL environment.  \n\nTheseus follows three design principles: P1. Require runtime-persistent bounds for all cells. P2. Maximize the power of the language and compiler. P3. Minimize state spill between cells.  \n\nThe remainder of this section describes how Theseus satisfies the first principle and why it matters, while $\\S4$ and $\\S5$ discuss the second and third principles, respectively.  \n\n3.1 Structure of Runtime-Persistent Cells  \n\nCells in Theseus have bounds that are clearly defined at implementation time and persist into and throughout runtime: a cell exists as a Rust crate at implementation time, a single object file at compile time, and a set of loaded memory regions with per-section bounds and dependency metadata at runtime. This applies to all cells, not just a select subset such as kernel extensions in monolithic and safe-language OSes or userspace servers in microkernels; there are no exemptions for components within a “base kernel” image. Explicit cell bounds identifiable at runtime are the foundation for strong data/fault isolation and state management in Theseus.  \n\nAt runtime, Theseus loads and links all cells into the system on demand. Briefly, this entails finding and parsing the cell object file, loading its sections into memory, resolving its dependencies to write linker relocation entries, recursively loading any missing cells as needed, and adding new public symbols to a symbol map. In doing so, Theseus constructs detailed cell metadata, depicted in Figure 1, which is crucial knowledge for live evolution (§6.1) and fault recovery $(\\S6.2)$ . The set of loaded cells defines a CellNamespace, a true namespace containing all cells’ public symbols, used to quickly resolve dependencies between cells. Each loaded cell node tracks its constituent sections and the memory regions $(\\S4.3.1)$ that contain them. The sections in each cell correspond to those in its crate’s object file, e.g., executable, read-only data, and read-write data sections. Each loaded section node tracks its size, location in memory, and bidirectional dependencies (incoming and outgoing); additional metadata exists to accelerate cell swapping and other system functions.  \n\nPersistence of Cell Bounds Reduces Complexity: Theseus’s persistent cell bounds provide a consistent abstraction of OS structure throughout all phases of their existence. This reduces the complexity of a developer’s mental model of the OS and simplifies fault recovery and evolution logic, as Theseus can introspect upon and manage its own code from the same cell-oriented viewpoint at runtime. The SAS/SPL environment augments this consistent view with completeness, in that everything from top-level applications and libraries to core kernel components are observable as cells. This enables Theseus to (i) implement a single mechanism, cell swapping, uniformly applicable to any cell, and $(i i)$ jointly evolve cells from multiple system layers (e.g., applications and kernel components) in a safe manner.  \n\n  \nFigure 1: Theseus constructs detailed metadata that tracks runtime cell bounds in memory and bidirectional, per-section dependencies in order to simplify cell swapping logic.  \n\nStriking a Balance with Cell Granularity: Theseus cells are elementary in their scope; we follow separation of concerns to split functionality into many tiny crates, letting unavoidable circular dependencies between them halt further decomposition. We do not use Rust’s source-level module hierarchy in which one crate contains multiple Rust (sub)modules, as those module bounds are lost when the crate is built into an object flie. Instead, we extract would-be modules into distinct crates, realizing hierarchy by organizing crates’ source files into folders in Theseus’s repository. This design offers both a programmer-friendly hierarchical view of source code and a simple system view of all cells as a flat set of distinct object files. It also strikes a balance between the complexity of needing to swap myriad tiny cells and the inefficiency and impracticality of swapping a large monolithic cell.  \n\n3.2 Bootstrapping Theseus with the nano_core  \n\nTheseus splits the compilation process at the linker stage, placing raw cell object files directly into the OS image such that linkage is deferred to runtime. From a practical standpoint, unlinked object files cannot run, so we must jump-start Theseus with the nano_core. The nano_core is a set of normal cells statically linked together into a tiny, executable “base kernel” image, comprising only components needed to bootstrap a bare-minimum environment that supports virtual memory and loading/linking object files. Because statically linking cells loses their bounds and dependencies, the nano_core fully replaces itself at the final bootstrap stage by dynamically loading its constituent cells one by one, using augmented symbol tables and other metadata burned into the OS image at build time. This meets the requirement of runtime-persistent bounds for all cells, allowing the nano_core to be safely unloaded after bootstrap.  \n\n4 Power to the Language  \n\nThe second design principle Theseus follows is to leverage the power of the language by enabling the compiler to check safety and correctness invariants to the fullest extent possible. We term this approach intralingual, within the language, as it involves matching Theseus’s execution environment to that of the language’s runtime model, and implementing OS semantics fully within the strong, static type system offered by modern languages like Rust. This extends compiler-checked invariants (e.g., no dangling references) to all types of resources, not just those built into the language.  \n\nIntralingual design offers two primary benefits. First, it empowers the compiler to take over resource management duties, reducing the states the OS must maintain, which in turn reduces state spill and strengthens isolation. Second, it enables the compiler to apply safety checks with no gaps in its understanding of code behavior, approaching end-toend safety from applications to core kernel components and shifting semantic runtime errors into compile-time errors.  \n\nIn contrast, traditional extralingual approaches rely on hardware protection and runtime checks to uphold invariants for safety, isolation, and correctness. These features are transparent to the compiler and require unsafe code. Even existing safe-language OSes [3, 13, 33, 44] have a gap between language-level safe code and the underlying unsafe core that implements the language’s required abstractions as a black box. Below, we describe how Theseus closes this gap and opens up such black boxes to the compiler.  \n\n4.1 Matching the Language’s Runtime Model  \n\nThe compiler for many languages, including Rust, expects that its output will become (part of) an executable that runs within one address space and privilege level, e.g., a single userspace process. Thus, the compiler cannot holistically observe or check the behavior of independently-compiled components that run in different address spaces or privilege levels.  \n\nTo address this shortcoming, we tailor Theseus’s OS execution environment to match Rust’s runtime model: $(i)$ only a single address space (SAS) exists and thus a single set of addresses is visible, for which Theseus guarantees a one-toone virtual-to-physical mapping; $(i i)$ all code executes within a single privilege level (SPL), thus there is no other world or mode of execution; $(i i i)$ only a single allocator instance exists, matching the compiler’s expectation that a global heap serves all allocation requests. Note that Theseus does support multiple arbitrary heaps within that single instance (§7.3).  \n\n4.2 Intralingual OS Design  \n\nMatching the language’s runtime model only allows the compiler to view all Theseus components. For the compiler to understand those components and apply its safety checks to them, we must implement them in a manner that exposes their safety requirements, invariants, and semantics to the compiler. As an aside, Theseus uses safe code to the fullest extent possible at all layers of the system, prioritizing safety over all else, e.g., convenience, performance. It only descends into unsafety when fundamentally unavoidable: executing instructions directly above hardware and select functions within Rust’s foundational libraries, i.e., core and alloc.  \n\nTheseus goes beyond language safety to further empower the compiler to check our custom OS invariants as if they were built in. First, for each OS resource, Theseus identifies the set of invariants that prevent unsafety and incorrect usage. As the Rust compiler already checks myriad invariants for the usage of language-provided types and mechanisms, Theseus employs these existing mechanisms to allow its resource-specific invariants to be subsumed into those compiler invariants. For example, Theseus uses Rust’s built-in reference types, such as &T and $\\mathsf{A r c}{}$ (Atomic Reference-Counted pointer), to share resources (e.g., memory regions, channel endpoints) across multiple tasks in a safe language-level manner, instead of extralingual sharing mechanisms like raw pointers or mapping multiple pages to the same frame. This eliminates possible use-after-free errors by subsuming resource mismanagement checks into the compiler’s lifetime invariants.  \n\nSecond, Theseus employs lossless interfaces for both external functions that export a resource’s semantics and internal functions that implement those semantics. An interface is lossless if crossing it preserves all language-level context, e.g., an object’s type, lifetime, or ownership/borrowed status. Furthermore, the provenance of that language-level context must be statically determinable, such that the compiler can authenticate that there was no broken link in the chain of calls and interface crossings when using a given resource. In other words, language-level knowledge must not be lost and then reconstituted extralingually. For example, invoking a system call in Linux loses the type and lifetime information of its arguments because they must be reduced to raw integer values to cross the user-kernel boundary.  \n\nEnsuring Resource Cleanup via Unwinding  \n\nOne major invariant we enforce beyond default Rust safety is to prevent resource leakage, an acquired resource not being released even after no references to it remain. Although leakage does not violate safety, it is generally incorrect behavior. Theseus prevents resource leakage by $(i)$ implementing all cleanup semantics in drop handlers (§2), a lossless languagelevel approach that allows the compiler to solely determine when it is safe to trigger resource cleanup, and $(i i)$ employing stack unwinding to ensure acquired resources are always released in both normal and exceptional execution.  \n\nWhen tasks acquire resources in Theseus, they directly own objects representing those resources on their stack (§5.1). The Rust compiler tracks ownership of those objects to statically determine when a resource is dropped and, thus, where to insert its cleanup routine. Implementing all resource cleanup in only drop handlers frees developers from the burden of correctly ordering release operations or considering corner cases such as exceptional control flow jumps. Applying this to acquired locks allows Theseus to statically prevent many cases of deadlock: lock guards are auto-released during unwinding, and domain-specific locks automatically disable/re-enable preemption or interrupts, e.g., when modifying task runstates.\n\nWe implement Theseus’s unwinder from scratch in Rust, with custom unwinding logic based on the DWARF standard [1] but independent from existing unwind libraries; thus, it works in core OS contexts without a standard library or allocation. Theseus starts the unwinder only upon a software or hardware exception or a request to kill a task; it does not interfere with normal execution performance, unlike garbage collectors. This prevents failed or uncooperative tasks from jeopardizing resource release and reclamation, strengthening fault isolation. The unwinder uses compiler-emitted information along with cell metadata to locate previous frames in the call stack, calculate and restore register values present during that frame, and discover and invoke cleanup routines or exception-catching blocks. Cell metadata even enables the unwinder to traverse through nonstandard stack frames for hardware-entered asynchronous calling contexts, e.g., interrupts or CPU exception handlers.  \n\nTheseus supports intralingual resource revocation in two forms. First, Theseus can forcibly revoke generic resources by killing and unwinding an uncooperative task. This avoids isolation-breaking undefined behavior by ceasing to execute a task once its assumptions of safe resource access no longer hold. Second, Theseus can cooperatively revoke reclaimable resources, such as in-memory caches and buffer pools, which express the possibility of resource absence within their type definition, e.g., using Option or weak references. This design unifies system-level and language-level resource actions to guarantee that revoked resources are freed exactly once.  \n\n4.3 Examples of Intralingual Subsystems  \n\nWe next describe how Theseus intralingually implements foundational OS resources, namely memory management and task management. Additional invariants, details, and examples, such as inter-task communication (ITC) channels, are omitted for brevity and available elsewhere [15].  \n\n4.3.1 Memory Management  \n\nTheseus intralingually implements virtual memory via the MappedPages type of Listing 2, which represents a region of virtually-contiguous pages statically guaranteed to be mapped to (optionally contiguous) real physical frames. MappedPages is the fundamental, sole way to map and access memory in Theseus, and serves as the backing representation for stacks, heaps, and arbitrary memory regions, e.g., device MMIO and loaded cells. The design of MappedPages empowers the compiler’s type system to enforce the following key invariants, extending Rust’s memory safety checks to all OS memory regions, not just the compiler-known stack and heap.  \n\nM.1: The mapping from virtual pages to physical frames must be one-to-one, or bijective. This prevents aliasing (sharing) from occurring beneath the language, forcing all shared memory access in Theseus to use only language-level mechanisms, such as references (&MappedPages). In Theseus’s SAS environment (§4.1), this is both possible and non-restrictive. In contrast, both conventional and existing safe-language OS  \n\n1 fn main() - $->$ Result {   \n2 let frames $=$ get_hpet_frames()?;   \n3 let pages $=$ allocate_pages(frames.count())?;   \n4 let mp_pgs $=$ map(pages, frames, flags, pg_tbl)?;   \n5 {   \n6 let hpet: &HpetRegisters $=$ mp_pgs.as_type(0)?;   \n7 print!(\"HPET device Vendor ID: {}\", hpet.caps_id.read() $>>16!$ ;   \n8 }   \n9 let (sender, receiver) $=$ rendezvous::new_channel::();   \n10 let new_task $=$ spawn_task(receiver_task, receiver)?;   \n11 sender.send(mp_pgs)?;   \n12 Ok(()) // \\ not dropped, it was moved   \n13 }   \n14 fn receiver_task(receiver: Receiver) - $\\cdot>$ Result {   \n15 let mp: MappedPages $=$ receiver.receive()?;   \n16 let hpet: &HpetRegisters $=$ mp.as_type(0)?;   \n17 print!(\"Current HPET ticks: $\\{\\}^{\\prime\\prime}$ , hpet.main_counter.read());   \n18 Ok(()) // \\ auto-dropped and unmapped here   \n19 }   \n20 struct HpetRegisters {   \n21 pub caps_and_id: ReadOnly,   \n22 _padding: [u64, ...],   \n23 pub main_counter: Volatile,   \n24   \n25 }  \n\ndesigns allow different virtual pages to map the same physical frame, an extralingual approach that renders sharing transparent to the compiler and thus uncheckable for safety.  \n\nWe realize this invariant via the map() function (L26), which leverages type safety to take ownership of the allocated pages and frames in order to return a new MappedPages object. The lossless map() interface statically ensures the provenance of this relationship between AllocatedPages, AllocatedFrames, and MappedPages, guaranteeing they cannot be reused for duplicate mappings.  \n\nM.2: Memory must not be accessible beyond the mapped region’s bounds. To access a memory region, one must use MappedPages methods like as_type() (L45) or as_slice() (L52) that overlay a statically-sized struct or dynamicallysized slice atop it; mutable versions exist, see M.4 below. The in-bounds invariant (L46) is checked dynamically unless elided when the size and offset are statically known, as in some MMIO cases. These access functions are lossless because they return sized types that preserve the lifetime relationship described below.  \n\nM.3: A memory region must be unmapped exactly once, only after there remain no outstanding references to it. MappedPages realizes its release and cleanup semantics only within its drop handler (L38), ensuring that a MappedPages object, such as mp in L15 of Listing 1, is unmapped in both normal execution (L18) and exceptional execution. Correspondingly, memory must not be accessible after it has been unmapped. The above access methods tie the lifetime of the re-typed borrowed reference &'m T to the lifetime of its backing MappedPages memory region, allowing compiler lifetime checks to statically prevent use-after-free. As such, obtaining ownership of an overlaid struct is impossible by design, as  \n\n26 pub fn map(pages: AllocatedPages, frames: AllocatedFrames,   \nflags: EntryFlags, ...) $->$ Result {   \n27 for (page, frame) in pages.iter().zip(frames.iter()) {   \n28 let mut pg_tbl_entry $=$ pg_tbl.walk_to(page, flags)?   \n.get_pte_mut(page.pte_offset());   \n29 pg_tbl_entry.set(frame.start_addr(), flags)?;   \n30 }   \n31 Ok(MappedPages { pages, frames, flags })   \n32 }   \n33 pub struct MappedPages {   \n34 pages: AllocatedPages,   \n35 frames: AllocatedFrames,   \n36 flags: EntryFlags,   \n37 }   \n38 impl Drop for MappedPages {   \n39 fn drop(&mut self) {   \n40 // unmap here: clear page table entry, invalidate TLB.   \n41 // AllocatedPages/Frames are auto-dropped and deallocated.   \n42 }   \n43 }   \n44 impl MappedPages {   \n45 pub fn as_type\\!(\\&\\,^{\\prime}\\,\\mathsf{m}$ self, offset: usize) $->$ Result {   \n46 if offset $^+$ size_of::() $>$ self.size_in_bytes() {   \n47 return Error::OutOfBounds;   \n48 $\\}$   \n49 let typed_mem: ${\\mathbb{\\&T}}\\;=$ unsafe {   \n$\\&^{}.$ ((self.pages.start_addr() $+$ offset) as \\const T) };   \n50 Ok(typed_mem)   \n51 }   \n52 pub fn as_slice(&'m self, offset: usize, count: usize)   \n- $\\cdot>$ Result\\{\\ \\ldots\\ \\}$   \n53 }   \n54 pub trait TFunc $=$ FnOnce(A) -> R;   \n55 pub trait TArg $=$ Send $^+$ 'static;   \n56 pub trait TRet $=$ Send $^+$ 'static;   \n57 pub fn spawn_task(func: F, arg: A, ...) - $\\cdot>$ Result   \nwhere A: TArg, R: TRet, F: TFunc {   \n58 let stack $=$ alloc_stack(stack_size)?;   \n59 let mut new_task $=$ Task::new(task_name, stack, ...)?;   \n60 let trampoline_offset $=$ new_task.stack.size_in_bytes()   \nsize_of::() - size_of::();   \n61 let initial_context: &mut RegisterCtx $=$ new_task.stack   \n.as_type_mut(trampoline_offset)?;   \n62 \\initial_context $=$ RegisterCtx::new(task_wrapper::);   \n63 new_task.saved_stack_ptr $=$ initial_context as \\const RegisterCtx;   \n64 let func_arg: &mut Option\\mathsf{\\Omega}=$ new_task.stack.as_type_mut(0)?;   \n65 \\func_arg $=$ Some((func, arg));   \n66 Ok(TaskRef::new(new_task))   \n67 }   \n68 fn task_wrapper() -> ! where A: TArg, R: TRet, F: TFunc {   \n69 let opt: &mut Option\\mathsf{\\Omega}=$ current_task.stack   \n.as_type(0).unwrap();   \n70 let (func, arg) $=$ opt.take().unwrap();   \n71 let res: Result $=$ catch_unwind_with_arg(func, arg);   \n72 match res {   \n73 Ok(exit_value) $=>$ task_cleanup_success::(exit_value),   \n74 Err(kill_reason) $=>$ task_cleanup_failure::(kill_reason),   \n75 }   \n76 }   \n77 fn task_cleanup_success(exit_value: R) -> !   \nwhere A: TArg, R: TRet, F: TFunc {   \n78 current_task.set_as_exited(exit_value);   \n79 task_cleanup_final::()   \n80 }   \n81 fn task_cleanup_failure(kill_reason: KillReason) -> !   \nwhere A: TArg, R: TRet, F: TFunc {   \n82 current_task.set_as_killed(kill_reason);   \n83 task_cleanup_final::()   \n84 }   \n85 fn task_cleanup_final(curr_task: TaskRef) -> !   \nwhere A: TArg, R: TRet, F: TFunc {   \n86 runqueue::remove_task(current_task());   \n87 scheduler::schedule(); // task is descheduled, will never run again   \n88 loop { }   \n89 }  \n\nthat would lossily discard the above lifetime relationship.  \n\nM.4: A memory region must only be mutable or executable if mapped as such. We ensure this using dedicated types, MappedPagesMut and MappedPagesExec, that offer as_type_mut() and as_function(), which statically prevents page protection violations as described elsewhere [15].  \n\nIn summary, MappedPages bridges the semantic gap between the compiler’s and OS’s knowledge of memory, guaranteeing at compile time that unexpected invalid page faults cannot occur. Note that the necessary unsafe code in L49 is innocuous (see $\\S8$ ) as it merely indicates that the compiler cannot ensure the overlaid struct type has valid contents. Correctness of struct contents (e.g., HpetRegisters in L20) is unavoidably left to the developer. Regardless of developer mistakes, the compiler can still check that this unsafe code does not violate fault or data isolation because other invariants ensure it cannot produce dangling references (M.3) or access out-of-bounds addresses (M.2) beyond the reach of safe code. All other memory management code is safe down to the lowest level, where page table walks require extralingual code to accommodate hardware-defined page table formats.  \n\n4.3.2 Task Management  \n\nWhile MappedPages is the center of intralingual memory management, the Task struct in Theseus is minimized in both content and significance. Rather, task management centers around intralingual functions that leverage a consistent set of generic type parameters to handle each stage of the task life  \n\nListing 3: The interface to spawn a task (L57) creates a new task and sets up its stack such that it will jump to task_wrapper() upon first context switch, which will then invoke its entry function normally. Every function that handles a task lifecycle stage is parameterized with the same set of trait bounds (L54-56), ensuring that a task’s type information (function, argument, return type) is losslessly preserved across its entire lifecycle. Code simplified for brevity.  \n\ncycle, as shown in Listing 3: spawning and entering new tasks (L57,68), modifying task runstates as they run, and exiting and cleaning up tasks (L77,81,85). Theseus enforces the following invariants to empower the compiler to uphold memory safety and prevent resource leaks throughout the task lifecycle.  \n\nT.1: Spawning a new task must not violate memory safety. Rust already ensures this for multiple concurrent userspace threads, as long as they were created using its standard library thread type. Instead of using the standard library, Theseus provides its own task abstraction, overcoming the standard library’s need to extralingually accommodate unsafe, platformspecific thread interfaces, e.g. fork(). Theseus does not offer fork because it is known to be unsafe and unsuitable for SAS systems [7], as it extralingually duplicates task context, states, and underlying memory regions without reflecting that aliasing at the language level.  \n\nTheseus’s task abstraction preserves safety similarly to and as an extension of Rust threads. The spawn_task() interface (L57) requires specifying the exact type of the entry function F, argument A, and return type R, with the following constraints: (i) the entry function must be runnable only once (FnOnce in L54), $(i i)$ the argument and return type must be safe to transfer between threads (Send in L55-56), and $(i i i)$ the lifetime of said three types must outlast the duration of the task itself. All task lifecycle functions are lossless and have identical type parameters (F,A,R), allowing the compiler to naturally extend its safety guarantees to concurrent execution across multiple Theseus tasks and to statically prevent invalidlytyped task entry functions, arguments, and return values.  \n\nT.2: All task states must be released in all possible execution paths. Releasing task states requires special consideration beyond simply dropping a Task object to prevent resource leakage (§4.2). Task states such as the stack are used during unwinding and can only be cleaned up once unwinding is complete, and task cleanup comprises multiple stages that each permit varying levels of resource release. For example, a task’s stack and saved register context can be released when it is exited (L78) or killed (L82), but its runstate and exit value must persist until it has been reaped (not shown).  \n\nIn addition, there exist multiple potential paths in the end stages of the task lifecycle that each require different cleanup actions. When a task runs to completion, its entry function naturally returns execution to the task_wrapper (L73), which can then safely mark the task as exited with its exit value. When a task crashes, the exception handler starts the unwinding procedure to release all task-held resources, after which it invokes the task failure function (L81) that marks the task as crashed. Both normal and exceptional execution paths invoke a final task cleanup function (L85) that removes the task from runqueues and deschedules it. All of these functions are parameterized with $\\tt{$ types, a key part of intralingual fault recovery mechanisms like restartable tasks $(\\S6.2)$ .  \n\nT.3: All memory transitively reachable from a task’s entry function must outlive that task. Although all memory regions in Theseus are represented by MappedPages, which prevents use-after-free via lifetime invariants, it is difficult to use Rust lifetimes to sufficiently express the relationship between a task and arbitrary memory regions it accesses. This is because a Rust program running as a task cannot specify in its code that its variables bound to objects in memory are tied to the lifetime of an underlying MappedPages instance, as they are hidden beneath abstractions like stacks, heaps, or program sections. Even if possible, this would be highly unergonomic and inconvenient, rendering ownership useless. For example, all local stack variables would need to be defined as borrowed references with lifetimes derived from that of the MappedPages representing the stack.  \n\nThus, to uphold this invariant, we instead establish a chain of ownership: each task owns the cell that contains its entry function, and that cell owns any cells it depends on, given by the per-section dependencies in the cell metadata (§3.1). As such, the MappedPages regions containing all functions and data reachable from a task’s entry function are guaranteed to outlive that task itself. This avoids littering lifetime constraints across all program variables, and allows Rust code to be written normally with the standard assumption that the stack, heap, data, and text sections will always exist.  \n\nIn contrast, conventional task management leaves the enforcement of these invariants to the OS programmer, an extralingual approach. In Theseus, only swapping stack pointer registers during a context switch is not intralingual.  \n\n5 State Management in Theseus  \n\nThe third design principle Theseus follows is to minimize and ideally eliminate state spill in its cells. As Theseus’s component structure is based on cells, state spill can only occur in interactions (e.g., function calls) that cross a cell boundary and result in changed state(s) in the receiving cell.  \n\n5.1 Opaque Exportation through Intralinguality  \n\nTheseus employs opaque exportation to avoid state spill in client-server interactions: each client is responsible for owning the state that represents its progress with the server, hence exportation, but cannot arbitrarily introspect into or modify that server-private state due to type safety, hence opaque. Opaque exportation is only possible because Theseus’s safe, intralingual design enables shifting the burden of resource/progress bookkeeping from the OS into the compiler. This allows bookkeeping states to be distributed, or offloaded to each client, e.g., held only on a client task’s stack. Theseus’s unwinder can still find and invoke cleanup routines without needing OS knowledge about which resources a client has acquired, thus the server and OS at large need not maintain bookkeeping states for each client.  \n\nConversely, Theseus eschews traditional state encapsulation, in which a server holds all states representing its clients’ progress and resource usage [16, 17]. Such encapsulation constitutes state spill and causes fate sharing that breaks isolation: when a server crashes and loses its state, its clients will also fail. Opaque exportation still preserves information hiding [52], a primary benefit of encapsulation.  \n\nA corollary of opaque exportation is stateless communication (à la RESTful web architectures [24]), which dictates that everything necessary for a given request to be handled should be included in that request. Servers that employ stateless communication need not store intermediary states between successive client interactions, as future interactions will be self-sufficient, containing previously-exported states.  \n\nOpaque exportation enables Theseus to avoid common spillful abstractions such as handles. Client-side handles to server-owned data forces the server to maintain a global table that associates each client’s handle with its underlying resource object, a form of state spill. Theseus rejects handles in favor of a client directly owning the underlying resource object; for example, an application task owns a MappedPages object instead of a virtual address handle, as shown by mp_pgs in L4 of Listing 1. This relieves the server (mm cell) from the burden of maintaining a handle table, e.g., a list of virtual memory areas (VMAs) that correspond to the virtual addresses given to clients as handles for mapped regions. Note that clients are only responsible for owning, not cleaning up, objects that represent resources they acquired; when said object falls out of scope (or during unwinding), it is cleaned up via compile-time insertion of a server-provided cleanup routine, i.e., the object’s drop handler. Thus, Theseus decouples the duty of owning and holding a state from the responsibility of implementing and invoking its cleanup functionality.  \n\nAccommodating Multi-Client States: Server-defined resources may pertain to or be shared across more than one client. Thus, Theseus extends opaque exportation to enable all pertinent clients to jointly own that resource state, i.e., multi-client states. Joint ownership and resource sharing in general can be realized via heap-allocated objects with automatic reference counting (e.g., Arc); while this can be viewed as state spill into the heap, considering spill into the allocator itself is not useful for two reasons. First, heap allocations are represented by owned objects elsewhere that point back to the heap, e.g., types like Box or Arc. Therefore, it suffices to consider only the propagation of those owned objects when determining where state spill occurred, rather than observing the internal state of the heap itself. Second, state spill into the heap is unavoidable; every basic action from creating a new local string variable to invoking a function would constitute state spill into the heap or stack, rendering it a useless metric.  \n\n5.2 Management of Special States in Theseus  \n\nTheseus cells often hold soft states, those that can be lost or discarded without error [19,55]. Soft states exist for the sake of convenience or performance, e.g., an in-memory cache of a clock source’s period read from hardware. Although soft states technically constitute state spill, they can be idempotently re-obtained or recalculated with no impact on correctness. Therefore, Theseus permits soft states as harmless state spill with no adverse effects on evolution or availability.  \n\nWe identify unavoidable states in two general forms: (i) clientless states, those that hardware requires the OS to maintain on its behalf, and $(i i)$ states needed to handle asynchronous, hardware-invoked entry points that do not provide sufficient context. The former renders opaque exportation impossible and the latter violates stateless communication. In the first case, we cannot modify the behavior or capacity of underlying hardware to accommodate exported states. Thus, Theseus must hold these states to ensure they persist throughout all execution. Examples include low-level $\\mathbf{x}86$ structures like the Global Descriptor Table (GDT), Task State Segment (TSS), Interrupt Descriptor Table (IDT). In the second case, Theseus must store necessary contextual states with a static lifetime and scope that exceeds that of the asynchronous hardware event’s entry function, e.g., an interrupt handler.  \n\nTo preserve the interchangeability of server cells in both such cases, Theseus assigns their states a well-defined owner and static lifetime by moving them into state_db, a state storage facility with minimal semantics akin to key value databases. Any singleton cell can move its static state into state_db and get a weak reference in return, a form of soft state. The state_db retains interchangeability despite harboring states spilled from other cells, as it uniquely must cooperate in its own swapping process by hardening itself via serialization to nonvolatile storage. The only other similar cell is the cell manager, which must also serialize its cell metadata. This design decouples a hardware state’s lifetime from that of the server cell interacting with it, enabling said cell to be evolved without losing mandatory system-wide states.  \n\n5.3 Intralinguality and Spill Freedom: Examples  \n\nWe further illustrate the relationship between intralingual design and state spill freedom with two example subsystems: memory and task management.  \n\nMemory Management: Theseus’s MappedPages type (§4.3) eliminates state spill through opaque exportation: the client requesting the mapping owns the resultant MappedPages object, e.g., mp_pgs on L4, rather than the server (mm cell) that created it. In contrast, mm entities in existing OSes harbor state spill in the form of metadata representing each memory mapping, e.g., a list or table of virtual memory area (VMA) objects; clients must blindly trust that the underlying mapping and VMA persist throughout the usage of their virtual address handle. Importantly, we consider page tables to be hardware-required MMU states, much like $\\mathbf{x}86$ ’s GDT or TSS. Page table entries are not language-level objects with lasting variable name bindings in Theseus; thus, writing to a page table is a hardware-externalized side effect rather than state spill. Crucially, the state representing this side effect — the transition from “unmapped” to “mapped” — is not lost, but reflected in the client-side MappedPages object rather than a hidden server-side state change.  \n\nTask Management: Theseus’s intralingual design and its ensuing opaque exportation significantly reduce the scope and size of its Task struct, thus avoiding most instances of state spill from other subsystems into its task management cells. This is possible because the unwinder and compiler together retain the ability to fully clean up a task’s acquired resources, even those shared across tasks, without needing to consult its task structure for resource bookkeeping states. Theseus also moves task-related states specific to other OS features, e.g., runqueue and scheduler information, out of the task struct and into those components themselves. This better follows separation of concerns than conventional OSes that hoard a huge list of OS states needed for manual resource bookkeeping and task cleanup into a centralized, all-encompassing task struct. Such a task struct design causes myriad OS operations to spill state into the task management entities and results in crosscutting dependencies that closely entangle entities together, hindering their evolution or recovery. Thus, Theseus’s task struct can contain only the bare necessities, e.g., the task’s runstate, stack, and saved execution context (register values). Correspondingly, it excludes lists of open flies, open sockets, memory mappings, wait queues, etc.  \n\n6 Realizing Evolvability and Availability  \n\nTo demonstrate the utility of Theseus’s design, we implement mechanisms inside it to realize challenging computing goals: live evolution and fault recovery.  \n\n6.1 Live Evolution via Cell Swapping  \n\nThe fundamental evolutionary mechanism in Theseus is cell swapping, a multi-stage procedure that replaces $o$ “old” existing cells with $N$ “new” ones; $o$ need not equal N. (i) First, Theseus loads all new cells into a new empty CellNamespace (§3.1), an isolated linking environment. $(i i)$ Theseus then verifies dependencies bidirectionally: new cells must satisfy existing dependencies fulfliled by the old cells, and existing cells must satisfy the new cells’ dependencies. Isolated loading allows this to occur before making invasive changes to the running system. $(i i i)$ Theseus redirects all cells that depend on the old cells to depend on the corresponding new cells, which involves rewriting their relocation entries and dependency metadata, updating on-stack references to the old cells, and transferring states if necessary. $(i\\nu)$ Finally, Theseus atomically removes the old cells and symbols from the CellNamespace whilst moving in the new cells.  \n\nEvolving a running instance of Theseus is as easy as committing to its repository, which triggers our build server tool to re-compile Theseus and generate an evolution manifest file specifying which new cells shall replace which old ones. Maintainers can also select individual cells to evolve, and all others that must be evolved alongside them are automatically included to ensure a well-formed evolution manifest.  \n\nTheseus’s design facilitates cell swapping and simplifies known live update techniques like quiescence and state transfer. In stage $(i)$ , runtime cell bounds let Theseus’s dynamic loader ensure that a cell’s sections will not overlap or be interleaved in memory with those of another, allowing each cell to claim sole ownership of its memory regions and be cleanly removable in stage $(i\\nu)$ . Dynamic loading also produces precise dependency information, needed in stages $(i i)$ and (iii).  \n\nSpill-free design of cells in Theseus simplifies state transfer. As previously mentioned, opaque exportation allows a server cell to be more easily swapped because it need not maintain state between successive interactions with clients, increasing its quiescent periods. Stateless communication reduces a given function’s dependencies on other cells because it receives necessary states and function callbacks or closures via its arguments. Overall, this hastens the dependency rewriting and state transfer steps in stage (iii).  \n\nThe cell metadata accelerates cell swapping. In stage $(i i)$ , dependency verification amounts to a quick search for fullyqualified symbols in the CellNamespace’s symbol map. In stage (iii), Theseus need not scan every task’s stack, rather only a limited subset for which the old cells’ public functions or data are reachable from the task’s entry function; reachability is trivially determined by following dependency links in the metadata. Compile-time ownership semantics allow Theseus’s cell manager to fearlessly remove old cells and their symbols in stage $(i\\nu)$ without first checking for their usage elsewhere, as the compiler has already ensured a removed old cell will not be actually dropped and unloaded until it is no longer referred to by any other cells; this avoids a computationally-complex graph traversal over all metadata. Theseus’s intralingual design extends to transfer functions needed for evolving a data structure in stage $(i i i)$ . We allow and require such functions to be implemented intralingually using Rust’s type conversion traits, e.g., Into. Generation of transfer functions is ongoing work, thus the results reported in $\\S7.1$ use manually-implemented transfer functions.  \n\n6.2 Availability via Fault Recovery  \n\nWe next describe how Theseus recovers from language-level exceptions (Rust panics) and hardware-induced faults like CPU exceptions. Theseus follows a multi-stage, cascading approach towards fault recovery, taking increasingly drastic measures until normal execution is recovered. A system-wide fault log records fault context (e.g., instruction pointer, current task) and the recovery action taken in order to track progression through recovery stages and avoid recurring fault loops.  \n\nThe first recovery stage is to simply tolerate the fault by fully cleaning up a failed task via unwinding. This form of fault isolation allows other tasks that depend on resources shared with the failed task to continue running.  \n\nThe second recovery stage is to respawn a new instance of the failed task. We extend the existing task infrastructure (Listing 3) to provide a fully intralingual implementation of restartable tasks, in which the spawn interface further constrains the $ type parameters to enable the compiler to check that tasks are well-formed and safely restartable. The augmented trait bounds are F: $F n(A)\\rightarrow R+C$ lone and A: Send $^+$ Clone $^+$ 'static, which require that the entry function can be safely executed multiple times (F: Fn, not FnOnce) and the argument can be safely duplicated (Clone).  \n\nThe most significant recovery stage reuses the cell swapping mechanism $(\\S6.1)$ to replace corrupted cells with freshlyloaded instances at different memory locations. This approach addresses faults that occur on invalid accesses of cell data or text sections, indicating they have been corrupted (e.g., due to a hardware memory failure). This represents the simplest possible case of cell swapping, with no possibility of missing dependencies or changes to code or data types. Following this, the failed task is restarted (as above), which allows it to successfully execute atop the new cell instance(s).  \n\nNotably, Theseus’s fault recovery mechanisms operate with few dependencies, allowing it to tolerate faults in the lowest system layers in the face of multiple failed subsystems. The fault-critical TCB of components for each recovery stage are", "files_in_pdf": [{"path": ".pdf_temp/viewrange_chunk_1_1_5_1762082323/images/7dq8vd.jpg", "size": 73975}]}