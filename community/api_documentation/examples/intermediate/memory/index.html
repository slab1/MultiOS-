<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermediate Memory Examples - MultiOS API Documentation</title>
    <link rel="stylesheet" href="../../assets/css/main.css">
    <link rel="stylesheet" href="../../assets/css/interactive.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
</head>
<body>
    <header class="header">
        <nav class="navbar">
            <div class="nav-brand">
                <img src="../../assets/images/logo.svg" alt="MultiOS" class="logo">
                <span class="brand-text">MultiOS API Documentation</span>
            </div>
            <div class="nav-links">
                <a href="../../index.html" class="nav-link">Home</a>
                <a href="../../api_reference/" class="nav-link">API Reference</a>
                <a href="../../tutorials/" class="nav-link">Tutorials</a>
                <a href="../../guides/" class="nav-link">Guides</a>
                <a href="../../examples/" class="nav-link active">Examples</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon">ðŸŒ™</span>
                </button>
            </div>
        </nav>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="page-header">
                <h1 class="page-title">Intermediate Memory Examples</h1>
                <p class="page-description">
                    Advanced memory management patterns and data structures using MultiOS APIs.
                </p>
            </div>

            <div class="example-grid">
                <div class="example-card">
                    <h3>Memory Pool Implementation</h3>
                    <p>Create and manage a pool of pre-allocated memory blocks for efficient allocation.</p>
                    <div class="code-preview">
                        <pre><code class="language-rust">use multios::memory::{MemoryPool, PoolAllocator};
use std::collections::HashMap;

struct ObjectPool {
    pool: MemoryPool,
    available: Vec<*mut u8>,
    in_use: HashMap<usize, *mut u8>,
}

impl ObjectPool {
    fn new(pool_size: usize, object_size: usize) -> Self {
        let pool = MemoryPool::new(pool_size * object_size).unwrap();
        let mut available = Vec::new();
        
        for i in 0..pool_size {
            let ptr = unsafe { pool.allocate(object_size).unwrap() };
            available.push(ptr);
        }
        
        ObjectPool {
            pool,
            available,
            in_use: HashMap::new(),
        }
    }
    
    fn acquire(&mut self, object_size: usize) -> Option<*mut u8> {
        if let Some(ptr) = self.available.pop() {
            let id = ptr as usize;
            self.in_use.insert(id, ptr);
            Some(ptr)
        } else {
            None
        }
    }
    
    fn release(&mut self, ptr: *mut u8) {
        if self.in_use.remove(&(ptr as usize)).is_some() {
            self.available.push(ptr);
        }
    }
}

// Usage example
fn main() {
    let mut pool = ObjectPool::new(100, 1024);
    
    // Acquire memory from pool
    let ptr1 = pool.acquire(1024).unwrap();
    let ptr2 = pool.acquire(1024).unwrap();
    
    println!("Acquired memory blocks at {:?} and {:?}", ptr1, ptr2);
    
    // Release back to pool
    pool.release(ptr1);
    pool.release(ptr2);
    
    println!("Returned memory blocks to pool");
}</code></pre>
                    </div>
                </div>

                <div class="example-card">
                    <h3>Shared Memory with Locking</h3>
                    <p>Implement thread-safe shared memory regions using MultiOS synchronization primitives.</p>
                    <div class="code-preview">
                        <pre><code class="language-rust">use multios::memory::{SharedMemory, MemoryRegion};
use multios::sync::{Mutex, RwLock};
use std::sync::Arc;

struct SharedData {
    counter: u64,
    data: Vec<u8>,
}

impl SharedData {
    fn new(size: usize) -> Self {
        SharedData {
            counter: 0,
            data: vec![0; size],
        }
    }
}

struct SharedMemoryManager {
    memory: Arc<Mutex<SharedMemory>>,
    data: Arc<RwLock<SharedData>>,
}

impl SharedMemoryManager {
    fn new(size: usize) -> Result<Self, Box<dyn std::error::Error>> {
        let memory = SharedMemory::create(size)?;
        let data = Arc::new(RwLock::new(SharedData::new(size)));
        
        Ok(SharedMemoryManager {
            memory: Arc::new(Mutex::new(memory)),
            data,
        })
    }
    
    fn increment_counter(&self) -> Result<u64, Box<dyn std::error::Error>> {
        let mut data = self.data.write()?;
        data.counter += 1;
        Ok(data.counter)
    }
    
    fn read_data(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let data = self.data.read()?;
        Ok(data.data.clone())
    }
    
    fn write_data(&self, data: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
        let mut shared_data = self.data.write()?;
        if data.len() <= shared_data.data.len() {
            shared_data.data[..data.len()].copy_from_slice(data);
            Ok(())
        } else {
            Err("Data too large".into())
        }
    }
}

// Usage example
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let manager = SharedMemoryManager::new(4096)?;
    
    // Write some data
    manager.write_data(b"Hello, MultiOS!")?;
    
    // Read it back
    let read_data = manager.read_data()?;
    println!("Read data: {}", String::from_utf8_lossy(&read_data));
    
    // Increment counter multiple times
    for i in 0..5 {
        let counter = manager.increment_counter()?;
        println!("Counter: {}", counter);
    }
    
    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="example-card">
                    <h3>Memory-Mapped File I/O</h3>
                    <p>Efficiently read and write large files using memory mapping techniques.</p>
                    <div class="code-preview">
                        <pre><code class="language-rust">use multios::memory::MemoryMappedFile;
use multios::filesystem::{FileSystem, OpenMode};
use std::path::Path;

fn process_large_file<P: AsRef<Path>>(path: P) -> Result<(), Box<dyn std::error::Error>> {
    let fs = FileSystem::new();
    
    // Create a large file for demonstration
    let file_path = path.as_ref();
    let mut file = fs.create_file(file_path)?;
    
    // Write test data
    for i in 0..1000000 {
        let line = format!("Line {}: The quick brown fox jumps over the lazy dog\n", i);
        file.write_all(line.as_bytes())?;
    }
    file.flush()?;
    drop(file);
    
    // Memory-map the file
    let mmap = unsafe { MemoryMappedFile::map(file_path, OpenMode::ReadWrite)? };
    
    // Process the mapped memory
    let content = mmap.as_slice();
    let lines: Vec<&str> = content.lines().collect();
    
    println!("Total lines in file: {}", lines.len());
    
    // Modify some lines in memory
    let mut mmap_mut = mmap.make_mutable()?;
    let first_line = b"Modified Line 0: Hello, MultiOS!\n";
    if first_line.len() <= 100 {
        mmap_mut[..first_line.len()].copy_from_slice(first_line);
    }
    
    // Synchronize changes back to disk
    mmap_mut.sync()?;
    
    Ok(())
}

fn search_in_mapped_file<P: AsRef<Path>>(path: P, search_term: &str) -> Result<usize, Box<dyn std::error::Error>> {
    let mmap = unsafe { MemoryMappedFile::map(path, OpenMode::Read)? };
    let content = mmap.as_slice();
    
    let mut matches = 0;
    let search_bytes = search_term.as_bytes();
    
    for i in 0..=(content.len().saturating_sub(search_bytes.len())) {
        if &content[i..i + search_bytes.len()] == search_bytes {
            matches += 1;
        }
    }
    
    Ok(matches)
}

// Usage examples
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create and process a large file
    process_large_file("/tmp/large_data.txt")?;
    
    // Search in the mapped file
    let matches = search_in_mapped_file("/tmp/large_data.txt", "fox")?;
    println!("Found {} occurrences of 'fox'", matches);
    
    Ok(())
}</code></pre>
                    </div>
                </div>

                <div class="example-card">
                    <h3>Custom Memory Allocator</h3>
                    <p>Implement a custom memory allocator with debugging and tracking features.</p>
                    <div class="code-preview">
                        <pre><code class="language-rust">use multios::memory::{Allocator, MemoryManager};
use std::collections::HashMap;
use std::sync::Mutex;

struct DebugAllocator {
    inner: MemoryManager,
    allocations: Mutex<HashMap<*mut u8, AllocationInfo>>,
    total_allocated: Mutex<usize>,
}

#[derive(Debug, Clone)]
struct AllocationInfo {
    size: usize,
    file: &'static str,
    line: u32,
}

impl DebugAllocator {
    fn new() -> Self {
        DebugAllocator {
            inner: MemoryManager::new(),
            allocations: Mutex::new(HashMap::new()),
            total_allocated: Mutex::new(0),
        }
    }
    
    fn allocate_with_debug(&self, size: usize, file: &'static str, line: u32) -> Result<*mut u8, Box<dyn std::error::Error>> {
        let ptr = self.inner.allocate(size)?;
        
        let info = AllocationInfo { size, file, line };
        
        let mut allocations = self.allocations.lock().unwrap();
        let mut total = self.total_allocated.lock().unwrap();
        
        allocations.insert(ptr, info);
        *total += size;
        
        println!("ALLOC: {:?} ({} bytes) at {}:{}", ptr, size, file, line);
        println!("Total allocated: {} bytes", *total);
        
        Ok(ptr)
    }
    
    fn deallocate_with_debug(&self, ptr: *mut u8, size: usize) -> Result<(), Box<dyn std::error::Error>> {
        let mut allocations = self.allocations.lock().unwrap();
        let mut total = self.total_allocated.lock().unwrap();
        
        if let Some(info) = allocations.remove(&ptr) {
            if info.size != size {
                println!("WARNING: Size mismatch during deallocation!");
                println!("Expected: {}, Actual: {}", info.size, size);
            }
            *total -= info.size;
            println!("DEALLOC: {:?} ({} bytes) at {}:{}", ptr, size, info.file, info.line);
            println!("Total allocated: {} bytes", *total);
        } else {
            println!("WARNING: Attempted to deallocate untracked pointer {:?}", ptr);
        }
        
        self.inner.deallocate(ptr, size)
    }
    
    fn get_memory_stats(&self) -> MemoryStats {
        let allocations = self.allocations.lock().unwrap();
        let total = *self.total_allocated.lock().unwrap();
        
        MemoryStats {
            total_allocated: total,
            allocation_count: allocations.len(),
            allocations: allocations.clone(),
        }
    }
}

#[derive(Debug, Clone)]
struct MemoryStats {
    total_allocated: usize,
    allocation_count: usize,
    allocations: HashMap<*mut u8, AllocationInfo>,
}

// Convenience macros for debugging
#[macro_export]
macro_rules! debug_allocate {
    ($size:expr, $allocator:expr) => {
        $allocator.allocate_with_debug($size, file!(), line!())
    };
}

#[macro_export]
macro_rules! debug_deallocate {
    ($ptr:expr, $size:expr, $allocator:expr) => {
        $allocator.deallocate_with_debug($ptr, $size)
    };
}

// Usage example
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let allocator = DebugAllocator::new();
    
    // Allocate memory with debugging
    let ptr1 = debug_allocate!(1024, &allocator)?;
    let ptr2 = debug_allocate!(2048, &allocator)?;
    
    // Deallocate memory
    debug_deallocate!(ptr1, 1024, &allocator)?;
    debug_deallocate!(ptr2, 2048, &allocator)?;
    
    // Get final statistics
    let stats = allocator.get_memory_stats();
    println!("Final memory stats: {:?}", stats);
    
    Ok(())
}</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 MultiOS Project. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/theme.js"></script>
</body>
</html>