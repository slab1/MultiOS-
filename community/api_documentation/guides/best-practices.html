<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best Practices - MultiOS Documentation</title>
    <link rel="stylesheet" href="../../assets/css/main.css">
    <link rel="stylesheet" href="../../assets/css/components.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <div class="logo">
                        <a href="../../index.html">
                            <i class="fas fa-microchip"></i>
                            <h1>MultiOS API Documentation</h1>
                        </a>
                    </div>
                    <div class="header-actions">
                        <div class="search-container">
                            <i class="fas fa-search"></i>
                            <input type="text" id="global-search" placeholder="Search API, tutorials, examples...">
                            <div id="search-results" class="search-results"></div>
                        </div>
                        <div class="theme-toggle">
                            <button id="theme-toggle" class="btn-icon">
                                <i class="fas fa-moon"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Navigation -->
        <nav class="sidebar">
            <div class="nav-content">
                <div class="nav-section">
                    <h3>API Reference</h3>
                    <ul>
                        <li><a href="../../api_reference/kernel.html" class="nav-link">Kernel API</a></li>
                        <li><a href="../../api_reference/memory.html" class="nav-link">Memory Management</a></li>
                        <li><a href="../../api_reference/process.html" class="nav-link">Process Management</a></li>
                        <li><a href="../../api_reference/filesystem.html" class="nav-link">File System</a></li>
                        <li><a href="../../api_reference/networking.html" class="nav-link">Network</a></li>
                        <li><a href="../../api_reference/drivers.html" class="nav-link">Driver API</a></li>
                        <li><a href="../../api_reference/gui.html" class="nav-link">GUI Framework</a></li>
                    </ul>
                </div>
                <div class="nav-section">
                    <h3>Tutorials</h3>
                    <ul>
                        <li><a href="../../tutorials/beginner/index.html" class="nav-link">Beginner</a></li>
                        <li><a href="../../tutorials/intermediate/index.html" class="nav-link">Intermediate</a></li>
                        <li><a href="../../tutorials/advanced/index.html" class="nav-link">Advanced</a></li>
                    </ul>
                </div>
                <div class="nav-section">
                    <h3>Guides</h3>
                    <ul>
                        <li><a href="integration/rust.html" class="nav-link">Rust Integration</a></li>
                        <li><a href="integration/c.html" class="nav-link">C Integration</a></li>
                        <li><a href="integration/python.html" class="nav-link">Python Integration</a></li>
                        <li><a href="integration/javascript.html" class="nav-link">JavaScript Integration</a></li>
                        <li><a href="integration/cpp.html" class="nav-link">C++ Integration</a></li>
                        <li><a href="integration/go.html" class="nav-link">Go Integration</a></li>
                    </ul>
                </div>
                <div class="nav-section">
                    <h3>Reference</h3>
                    <ul>
                        <li><a href="best-practices.html" class="nav-link active">Best Practices</a></li>
                        <li><a href="../../api-explorer.html" class="nav-link">API Explorer</a></li>
                        <li><a href="../../validation/api-tester.html" class="nav-link">API Tester</a></li>
                    </ul>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="container">
                <div class="content-header">
                    <h1>MultiOS Best Practices</h1>
                    <p class="lead">Essential guidelines and patterns for building robust MultiOS applications</p>
                    <div class="content-meta">
                        <span class="badge badge-difficulty">All Levels</span>
                        <span class="badge badge-ecosystem">Guidelines</span>
                    </div>
                </div>

                <!-- General Principles -->
                <section class="content-section">
                    <h2>General Development Principles</h2>
                    <p>These fundamental principles apply across all programming languages and development scenarios on MultiOS.</p>
                    
                    <div class="principle-grid">
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-shield-alt"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Memory Safety</h3>
                                <p>Always validate memory allocations and use appropriate memory management patterns for your language. Prefer stack allocation when possible, and always clean up heap allocations.</p>
                            </div>
                        </div>
                        
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-error"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Error Handling</h3>
                                <p>Implement comprehensive error handling at all levels. Always check return values, handle exceptions gracefully, and provide meaningful error messages to users.</p>
                            </div>
                        </div>
                        
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-tachometer-alt"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Performance Awareness</h3>
                                <p>Design with performance in mind from the beginning. Use appropriate data structures, avoid unnecessary allocations, and profile critical code paths regularly.</p>
                            </div>
                        </div>
                        
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-cogs"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Modularity</h3>
                                <p>Write modular, reusable code with clear interfaces. Separate concerns, minimize coupling, and maximize cohesion for maintainable applications.</p>
                            </div>
                        </div>
                        
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-comments"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Documentation</h3>
                                <p>Document your code thoroughly with clear comments, docstrings, and usage examples. Good documentation reduces bugs and improves developer experience.</p>
                            </div>
                        </div>
                        
                        <div class="principle-card">
                            <div class="principle-icon">
                                <i class="fas fa-check-circle"></i>
                            </div>
                            <div class="principle-content">
                                <h3>Testing</h3>
                                <p>Write comprehensive tests including unit tests, integration tests, and edge case validation. Automated testing ensures reliability and prevents regressions.</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Language-Specific Best Practices -->
                <section class="content-section">
                    <h2>Language-Specific Best Practices</h2>
                    
                    <!-- Rust Best Practices -->
                    <div class="language-section">
                        <h3><i class="fab fa-rust"></i> Rust Best Practices</h3>
                        
                        <div class="practice-item">
                            <h4>Ownership and Borrowing</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Clear ownership semantics</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-rust">// Use references for read-only access
fn process_data(data: &[String]) -> Result<String, Error> {
    let mut result = String::new();
    for item in data {
        result.push_str(item);
    }
    Ok(result)
}

// Use mutable references when you need to modify
fn update_config(config: &mut Config, new_value: &str) -> Result<(), Error> {
    config.value = new_value.to_string();
    Ok(())
}</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Error Handling with Result</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Comprehensive error handling</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};

fn read_file_content(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;
    Ok(content)
}

// Handle specific error types
fn process_file(path: &str) -> Result<Data, Box<dyn std::error::Error>> {
    match read_file_content(path) {
        Ok(content) => {
            // Process content
            Ok(parse_data(&content)?)
        }
        Err(e) if e.kind() == io::ErrorKind::NotFound => {
            Err(format!("File not found: {}", path).into())
        }
        Err(e) => {
            Err(format!("Failed to read file: {}", e).into())
        }
    }
}</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Concurrency Patterns</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Safe concurrent operations</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn parallel_processing<T: Send + 'static>(
    data: Vec<T>,
    processor: impl Fn(T) -> T + Send + Sync + 'static,
) -> Vec<T> {
    let data = Arc::new(Mutex::new(data));
    let mut handles = vec![];

    for _ in 0..4 { // CPU cores
        let data = Arc::clone(&data);
        let processor = &processor;
        
        handles.push(thread::spawn(move || {
            let mut local_data = vec![];
            
            // Process items from shared data
            while let Some(item) = {
                let mut data = data.lock().unwrap();
                data.pop()
            } {
                local_data.push(processor(item));
            }
            
            local_data
        }));
    }

    // Collect results
    let mut results = vec![];
    for handle in handles {
        results.extend(handle.join().unwrap());
    }
    
    results
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- C Best Practices -->
                    <div class="language-section">
                        <h3><i class="fas fa-code"></i> C Best Practices</h3>
                        
                        <div class="practice-item">
                            <h4>Memory Management</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Proper memory management</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-c">// Use cleanup functions consistently
typedef struct {
    char *data;
    size_t length;
    size_t capacity;
} StringBuffer;

// Initialize with proper defaults
StringBuffer* string_buffer_create(void) {
    StringBuffer *buf = malloc(sizeof(StringBuffer));
    if (!buf) return NULL;
    
    buf->data = malloc(16);  // Initial capacity
    if (!buf->data) {
        free(buf);
        return NULL;
    }
    
    buf->length = 0;
    buf->capacity = 16;
    return buf;
}

// Always provide cleanup
void string_buffer_destroy(StringBuffer *buf) {
    if (buf) {
        free(buf->data);
        free(buf);
    }
}

// Use cleanup in error paths
int string_buffer_append(StringBuffer *buf, const char *str) {
    if (!buf || !str) return -1;
    
    size_t str_len = strlen(str);
    if (buf->length + str_len >= buf->capacity) {
        // Resize buffer
        size_t new_capacity = buf->capacity * 2;
        char *new_data = realloc(buf->data, new_capacity);
        if (!new_data) return -1;
        
        buf->data = new_data;
        buf->capacity = new_capacity;
    }
    
    memcpy(buf->data + buf->length, str, str_len);
    buf->length += str_len;
    buf->data[buf->length] = '\0';
    return 0;
}</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Error Handling</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Consistent error handling</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-c">// Define error codes
typedef enum {
    ERROR_NONE = 0,
    ERROR_INVALID_ARGUMENT,
    ERROR_MEMORY_ALLOCATION,
    ERROR_FILE_NOT_FOUND,
    ERROR_PERMISSION_DENIED,
    ERROR_UNKNOWN
} ErrorCode;

// Use return codes consistently
ErrorCode process_file(const char *filename, Data *result) {
    if (!filename || !result) {
        return ERROR_INVALID_ARGUMENT;
    }
    
    FILE *file = fopen(filename, "r");
    if (!file) {
        if (errno == ENOENT) {
            return ERROR_FILE_NOT_FOUND;
        } else if (errno == EACCES) {
            return ERROR_PERMISSION_DENIED;
        } else {
            return ERROR_UNKNOWN;
        }
    }
    
    // Process file content
    // ... (file processing logic)
    
    fclose(file);
    return ERROR_NONE;
}

// Always check return codes
void process_user_input(const char *input) {
    Data result;
    ErrorCode error = process_file(input, &result);
    
    switch (error) {
        case ERROR_NONE:
            printf("Processing successful\n");
            break;
        case ERROR_FILE_NOT_FOUND:
            fprintf(stderr, "File not found: %s\n", input);
            break;
        case ERROR_PERMISSION_DENIED:
            fprintf(stderr, "Permission denied: %s\n", input);
            break;
        default:
            fprintf(stderr, "Unknown error occurred\n");
            break;
    }
}</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Thread Safety</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Thread-safe operations</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-c">#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

// Shared data structure with mutex
typedef struct {
    int value;
    pthread_mutex_t mutex;
    pthread_cond_t condition;
    int active_readers;
    int active_writers;
} SharedData;

SharedData* shared_data_create(void) {
    SharedData *data = malloc(sizeof(SharedData));
    if (!data) return NULL;
    
    data->value = 0;
    data->active_readers = 0;
    data->active_writers = 0;
    
    if (pthread_mutex_init(&data->mutex, NULL) != 0) {
        free(data);
        return NULL;
    }
    
    if (pthread_cond_init(&data->condition, NULL) != 0) {
        pthread_mutex_destroy(&data->mutex);
        free(data);
        return NULL;
    }
    
    return data;
}

// Reader-writer lock implementation
void shared_data_read_lock(SharedData *data) {
    pthread_mutex_lock(&data->mutex);
    data->active_readers++;
    pthread_mutex_unlock(&data->mutex);
}

void shared_data_read_unlock(SharedData *data) {
    pthread_mutex_lock(&data->mutex);
    data->active_readers--;
    if (data->active_readers == 0) {
        pthread_cond_signal(&data->condition);
    }
    pthread_mutex_unlock(&data->mutex);
}

int shared_data_read_value(SharedData *data) {
    shared_data_read_lock(data);
    int value = data->value;
    shared_data_read_unlock(data);
    return value;
}

void shared_data_write_lock(SharedData *data) {
    pthread_mutex_lock(&data->mutex);
    while (data->active_readers > 0 || data->active_writers > 0) {
        pthread_cond_wait(&data->condition, &data->mutex);
    }
    data->active_writers = 1;
}

void shared_data_write_unlock(SharedData *data) {
    data->active_writers = 0;
    pthread_cond_broadcast(&data->condition);
    pthread_mutex_unlock(&data->mutex);
}

void shared_data_write_value(SharedData *data, int value) {
    shared_data_write_lock(data);
    data->value = value;
    shared_data_write_unlock(data);
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Python Best Practices -->
                    <div class="language-section">
                        <h3><i class="fab fa-python"></i> Python Best Practices</h3>
                        
                        <div class="practice-item">
                            <h4>Context Managers and Resource Management</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Automatic resource cleanup</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-python">import contextlib
import tempfile
import os

# Custom context manager for file operations
@contextlib.contextmanager
def safe_file_operation(filepath, mode='r'):
    """Ensure file operations are handled safely with proper cleanup"""
    file_handle = None
    try:
        file_handle = open(filepath, mode)
        yield file_handle
    except IOError as e:
        print(f"File operation failed: {e}")
        raise
    finally:
        if file_handle:
            file_handle.close()

# Use context managers for database connections
@contextlib.contextmanager
def database_connection(db_path):
    """Database connection with automatic cleanup"""
    import sqlite3
    
    conn = sqlite3.connect(db_path)
    try:
        yield conn
    except Exception as e:
        conn.rollback()
        raise
    finally:
        conn.close()

# Example usage with nested context managers
def process_data_file(data_path, output_path):
    with safe_file_operation(data_path, 'r') as input_file:
        with safe_file_operation(output_path, 'w') as output_file:
            with database_connection(':memory:') as conn:
                # Process data
                for line in input_file:
                    processed = line.strip().upper()
                    output_file.write(processed + '\n')
                    
                    # Store in database
                    conn.execute('INSERT INTO data (content) VALUES (?)', (processed,))
    
    print(f"Processing completed: {data_path} -> {output_path}")

# Resource management with cleanup decorators
import functools
import threading
import time

def worker_cleanup(func):
    """Decorator to ensure worker threads are properly cleaned up"""
    active_workers = set()
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        worker_id = threading.current_thread().ident
        active_workers.add(worker_id)
        
        try:
            result = func(*args, **kwargs)
            return result
        finally:
            active_workers.discard(worker_id)
    
    # Add method to check active workers
    wrapper.get_active_workers = lambda: len(active_workers)
    return wrapper

@worker_cleanup
def background_worker(task_id):
    """Background worker that gets properly tracked"""
    time.sleep(0.1)  # Simulate work
    print(f"Worker {task_id} completed")
    return f"Result from worker {task_id}"</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Error Handling and Validation</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Comprehensive error handling</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-python">import logging
from typing import Optional, List, Dict, Any
from dataclasses import dataclass

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Custom exceptions
class ValidationError(Exception):
    """Custom validation error"""
    pass

class ProcessingError(Exception):
    """Custom processing error"""
    pass

@dataclass
class Config:
    """Application configuration with validation"""
    host: str
    port: int
    timeout: float
    max_retries: int
    
    def __post_init__(self):
        """Validate configuration after initialization"""
        if not self.host:
            raise ValidationError("Host cannot be empty")
        
        if not (1 <= self.port <= 65535):
            raise ValidationError(f"Port {self.port} is out of range")
        
        if self.timeout <= 0:
            raise ValidationError("Timeout must be positive")
        
        if self.max_retries < 0:
            raise ValidationError("Max retries cannot be negative")

class DataProcessor:
    """Data processor with comprehensive error handling"""
    
    def __init__(self, config: Config):
        self.config = config
        self.processed_count = 0
        self.error_count = 0
    
    def process_data(self, data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Process data with comprehensive error handling"""
        results = []
        
        for i, item in enumerate(data):
            try:
                # Validate input data
                self._validate_item(item)
                
                # Process item
                processed_item = self._process_item(item)
                results.append(processed_item)
                
                self.processed_count += 1
                logger.info(f"Processed item {i+1}/{len(data)}")
                
            except ValidationError as e:
                logger.warning(f"Validation error for item {i}: {e}")
                self.error_count += 1
                # Continue processing other items
                
            except ProcessingError as e:
                logger.error(f"Processing error for item {i}: {e}")
                self.error_count += 1
                # Consider whether to continue or fail fast
                
            except Exception as e:
                logger.error(f"Unexpected error for item {i}: {e}")
                self.error_count += 1
                # Log but don't crash the whole process
        
        # Summary logging
        logger.info(f"Processing completed: {self.processed_count} successful, {self.error_count} errors")
        return results
    
    def _validate_item(self, item: Dict[str, Any]) -> None:
        """Validate individual data item"""
        required_fields = ['id', 'name', 'value']
        
        for field in required_fields:
            if field not in item:
                raise ValidationError(f"Missing required field: {field}")
        
        if not isinstance(item['id'], int):
            raise ValidationError("Field 'id' must be an integer")
        
        if not isinstance(item['name'], str):
            raise ValidationError("Field 'name' must be a string")
        
        if not isinstance(item['value'], (int, float)):
            raise ValidationError("Field 'value' must be a number")
    
    def _process_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """Process individual data item"""
        # Simulate processing that might fail
        if item['value'] < 0:
            raise ProcessingError(f"Negative value not allowed: {item['value']}")
        
        # Process the item
        processed = item.copy()
        processed['processed'] = True
        processed['timestamp'] = time.time()
        
        return processed

# Example usage with error handling
def main():
    config = Config(
        host="localhost",
        port=8080,
        timeout=30.0,
        max_retries=3
    )
    
    processor = DataProcessor(config)
    
    test_data = [
        {'id': 1, 'name': 'item1', 'value': 10},
        {'id': 2, 'name': 'item2', 'value': 20},
        {'id': 3, 'name': '', 'value': 30},  # Invalid - empty name
        {'id': 4, 'name': 'item4', 'value': -5},  # Invalid - negative value
        {'id': 5, 'name': 'item5', 'value': 50},
    ]
    
    try:
        results = processor.process_data(test_data)
        print(f"Successfully processed {len(results)} items")
        
    except Exception as e:
        logger.error(f"Fatal error in main processing: {e}")
        raise

if __name__ == "__main__":
    main()</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- JavaScript Best Practices -->
                    <div class="language-section">
                        <h3><i class="fab fa-js"></i> JavaScript Best Practices</h3>
                        
                        <div class="practice-item">
                            <h4>Async/Await and Error Handling</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Proper async pattern usage</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-javascript">// Custom error classes
class MultiOSError extends Error {
    constructor(message, code, cause = null) {
        super(message);
        this.name = 'MultiOSError';
        this.code = code;
        this.cause = cause;
        this.timestamp = new Date().toISOString();
    }
}

class FileSystemError extends MultiOSError {
    constructor(message, path, cause = null) {
        super(message, 'FILE_SYSTEM_ERROR', cause);
        this.path = path;
    }
}

// Retry utility with exponential backoff
async function retryOperation(operation, maxRetries = 3, baseDelay = 1000) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        } catch (error) {
            lastError = error;
            
            if (attempt === maxRetries) {
                throw error;
            }
            
            // Exponential backoff
            const delay = baseDelay * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
            
            console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
        }
    }
    
    throw lastError;
}

// Async data processor with proper error handling
class AsyncDataProcessor {
    constructor(options = {}) {
        this.batchSize = options.batchSize || 100;
        this.concurrency = options.concurrency || 4;
        this.retryCount = options.retryCount || 3;
        this.onProgress = options.onProgress || (() => {});
    }
    
    async processItems(items, processor) {
        const results = [];
        const errors = [];
        let processed = 0;
        
        // Process items in batches with controlled concurrency
        for (let i = 0; i < items.length; i += this.batchSize) {
            const batch = items.slice(i, i + this.batchSize);
            
            const batchResults = await Promise.allSettled(
                batch.map(item => this.processItem(item, processor))
            );
            
            // Collect results and errors
            batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    results.push(result.value);
                } else {
                    errors.push({
                        item: batch[index],
                        error: result.reason
                    });
                }
                
                processed++;
                this.onProgress(processed, items.length);
            });
        }
        
        return { results, errors };
    }
    
    async processItem(item, processor) {
        return retryOperation(
            async () => {
                if (!this.validateItem(item)) {
                    throw new Error(`Invalid item: ${JSON.stringify(item)}`);
                }
                return await processor(item);
            },
            this.retryCount
        );
    }
    
    validateItem(item) {
        // Basic validation logic
        return item && 
               typeof item === 'object' && 
               'id' in item && 
               'data' in item;
    }
}

// Safe file operations with proper error handling
class SafeFileSystem {
    constructor(basePath = '/tmp') {
        this.basePath = basePath;
    }
    
    async readFile(filepath, options = {}) {
        return retryOperation(async () => {
            try {
                const fullPath = this.resolvePath(filepath);
                
                if (!await this.pathExists(fullPath)) {
                    throw new FileSystemError(`File not found: ${fullPath}`, fullPath);
                }
                
                // Actual file reading logic would go here
                const content = await this.performRead(fullPath);
                return content;
                
            } catch (error) {
                if (error instanceof FileSystemError) {
                    throw error;
                }
                
                // Wrap unexpected errors
                throw new FileSystemError(
                    `Failed to read file: ${error.message}`,
                    filepath,
                    error
                );
            }
        }, options.maxRetries || 3);
    }
    
    async writeFile(filepath, content, options = {}) {
        return retryOperation(async () => {
            try {
                const fullPath = this.resolvePath(filepath);
                
                // Ensure directory exists
                await this.ensureDirectory(this.dirname(fullPath));
                
                // Actual file writing logic would go here
                await this.performWrite(fullPath, content);
                
                return true;
                
            } catch (error) {
                throw new FileSystemError(
                    `Failed to write file: ${error.message}`,
                    filepath,
                    error
                );
            }
        }, options.maxRetries || 3);
    }
    
    // Utility methods
    resolvePath(filepath) {
        return filepath.startsWith('/') ? filepath : `${this.basePath}/${filepath}`;
    }
    
    async pathExists(path) {
        // Implementation would check if path exists
        return true; // Placeholder
    }
    
    async ensureDirectory(dirPath) {
        // Implementation would create directory if needed
        return true; // Placeholder
    }
    
    dirname(path) {
        const lastSlash = path.lastIndexOf('/');
        return lastSlash > 0 ? path.substring(0, lastSlash) : '/';
    }
    
    async performRead(path) {
        // Actual file reading implementation
        return 'file content'; // Placeholder
    }
    
    async performWrite(path, content) {
        // Actual file writing implementation
        return true; // Placeholder
    }
}

// Usage example
async function demonstrateAsyncPatterns() {
    const fs = new SafeFileSystem('/data');
    const processor = new AsyncDataProcessor({
        batchSize: 50,
        concurrency: 2,
        onProgress: (processed, total) => {
            console.log(`Progress: ${processed}/${total} (${Math.round(processed/total*100)}%)`);
        }
    });
    
    try {
        // Read configuration
        const config = await fs.readFile('config.json');
        console.log('Config loaded:', config);
        
        // Process data
        const testData = Array.from({ length: 250 }, (_, i) => ({
            id: i,
            data: `item-${i}`,
            timestamp: Date.now()
        }));
        
        const { results, errors } = await processor.processItems(
            testData, 
            async (item) => {
                // Simulate processing
                await new Promise(resolve => setTimeout(resolve, 10));
                return {
                    ...item,
                    processed: true,
                    result: item.data.toUpperCase()
                };
            }
        );
        
        console.log(`Processing complete: ${results.length} successes, ${errors.length} errors`);
        
        if (errors.length > 0) {
            console.log('Errors:', errors.slice(0, 5)); // Show first 5 errors
        }
        
    } catch (error) {
        if (error instanceof MultiOSError) {
            console.error(`Application error [${error.code}]: ${error.message}`);
        } else {
            console.error('Unexpected error:', error);
        }
    }
}</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h4>Memory Management and Cleanup</h4>
                            <div class="code-example">
                                <div class="code-header">
                                    <span>Good: Proper resource cleanup</span>
                                    <button class="btn-copy" onclick="copyCode(this)">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <pre><code class="language-javascript">// Resource cleanup with WeakMap and proper disposal
class ResourceManager {
    constructor() {
        this.resources = new WeakMap();
        this.cleanupHandlers = new Set();
        this.isDisposed = false;
    }
    
    registerResource(resource, cleanup) {
        if (this.isDisposed) {
            throw new Error('ResourceManager is disposed');
        }
        
        this.resources.set(resource, cleanup);
        
        // Return cleanup function
        return () => this.unregisterResource(resource);
    }
    
    unregisterResource(resource) {
        if (this.isDisposed) return;
        
        const cleanup = this.resources.get(resource);
        if (cleanup) {
            try {
                cleanup();
            } catch (error) {
                console.error('Error during resource cleanup:', error);
            }
            this.resources.delete(resource);
        }
    }
    
    dispose() {
        if (this.isDisposed) return;
        
        this.isDisposed = true;
        
        // Clean up all resources
        this.resources.forEach((cleanup, resource) => {
            try {
                cleanup();
            } catch (error) {
                console.error('Error during final cleanup:', error);
            }
        });
        
        this.resources = new WeakMap();
        this.cleanupHandlers.clear();
    }
}

// Network resource management
class NetworkManager extends ResourceManager {
    constructor() {
        super();
        this.activeConnections = new Map();
        this.requestQueue = [];
        this.maxConnections = 10;
    }
    
    async createConnection(endpoint, options = {}) {
        if (this.isDisposed) {
            throw new Error('NetworkManager is disposed');
        }
        
        const connectionId = this.generateConnectionId();
        const connection = await this.establishConnection(endpoint, options);
        
        // Register cleanup
        const cleanup = () => this.closeConnection(connectionId);
        this.registerResource(connection, cleanup);
        
        // Track connection
        this.activeConnections.set(connectionId, {
            connection,
            endpoint,
            createdAt: Date.now(),
            requestCount: 0
        });
        
        return { connectionId, connection };
    }
    
    async makeRequest(connectionId, request) {
        const connectionInfo = this.activeConnections.get(connectionId);
        if (!connectionInfo) {
            throw new Error(`Connection ${connectionId} not found`);
        }
        
        try {
            connectionInfo.requestCount++;
            const response = await this.performRequest(connectionInfo.connection, request);
            return response;
        } catch (error) {
            // Handle connection errors
            if (this.isRecoverableError(error)) {
                await this.recoverConnection(connectionId);
            }
            throw error;
        }
    }
    
    closeConnection(connectionId) {
        const connectionInfo = this.activeConnections.get(connectionId);
        if (!connectionInfo) return;
        
        try {
            this.teardownConnection(connectionInfo.connection);
        } catch (error) {
            console.error('Error closing connection:', error);
        }
        
        this.activeConnections.delete(connectionId);
    }
    
    async closeAllConnections() {
        const connectionIds = Array.from(this.activeConnections.keys());
        await Promise.all(
            connectionIds.map(id => this.closeConnection(id))
        );
    }
    
    // Helper methods (implementations would be specific to your network library)
    generateConnectionId() {
        return `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async establishConnection(endpoint, options) {
        // Implementation would create actual network connection
        return { endpoint, options, socket: null };
    }
    
    async performRequest(connection, request) {
        // Implementation would send actual request
        return { status: 200, data: 'response' };
    }
    
    teardownConnection(connection) {
        // Implementation would clean up network connection
        return true;
    }
    
    isRecoverableError(error) {
        // Define what errors are recoverable
        return error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT';
    }
    
    async recoverConnection(connectionId) {
        console.log(`Attempting to recover connection ${connectionId}`);
        // Implementation would attempt to re-establish connection
    }
}

// Event emitter with cleanup
class EventEmitter extends ResourceManager {
    constructor() {
        super();
        this.listeners = new Map();
    }
    
    on(event, handler) {
        if (this.isDisposed) {
            throw new Error('EventEmitter is disposed');
        }
        
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        
        this.listeners.get(event).add(handler);
        
        // Return unsubscribe function
        return () => this.off(event, handler);
    }
    
    off(event, handler) {
        if (this.isDisposed) return;
        
        const eventListeners = this.listeners.get(event);
        if (eventListeners) {
            eventListeners.delete(handler);
            
            if (eventListeners.size === 0) {
                this.listeners.delete(event);
            }
        }
    }
    
    emit(event, ...args) {
        if (this.isDisposed) return false;
        
        const eventListeners = this.listeners.get(event);
        if (!eventListeners || eventListeners.size === 0) {
            return false;
        }
        
        // Create copy to avoid issues if listeners are removed during emission
        const listeners = Array.from(eventListeners);
        
        for (const handler of listeners) {
            try {
                handler(...args);
            } catch (error) {
                console.error(`Error in event handler for '${event}':`, error);
            }
        }
        
        return true;
    }
    
    // Clean up all listeners on disposal
    dispose() {
        this.listeners.clear();
        super.dispose();
    }
}

// Usage example with proper cleanup
class Application {
    constructor() {
        this.networkManager = new NetworkManager();
        this.eventEmitter = new EventEmitter();
        
        // Setup cleanup handlers
        process.on('SIGINT', () => this.shutdown());
        process.on('SIGTERM', () => this.shutdown());
    }
    
    async initialize() {
        try {
            // Create connection
            const { connectionId } = await this.networkManager.createConnection(
                'https://api.example.com',
                { timeout: 5000 }
            );
            
            // Setup event listeners with automatic cleanup
            const unsubscribe = this.eventEmitter.on('data', (data) => {
                console.log('Received data:', data);
            });
            
            // Make request
            const response = await this.networkManager.makeRequest(
                connectionId,
                { method: 'GET', path: '/data' }
            );
            
            console.log('Response:', response);
            
            // Clean up specific listener
            unsubscribe();
            
        } catch (error) {
            console.error('Initialization failed:', error);
            throw error;
        }
    }
    
    async shutdown() {
        console.log('Shutting down application...');
        
        try {
            // Close all connections
            await this.networkManager.closeAllConnections();
            
            // Clean up resources
            this.networkManager.dispose();
            this.eventEmitter.dispose();
            
            console.log('Application shutdown complete');
            process.exit(0);
            
        } catch (error) {
            console.error('Error during shutdown:', error);
            process.exit(1);
        }
    }
}

// Usage
const app = new Application();
app.initialize().catch(error => {
    console.error('Failed to start application:', error);
    process.exit(1);
});</code></pre>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Cross-Language Patterns -->
                <section class="content-section">
                    <h2>Cross-Language Design Patterns</h2>
                    <p>Universal patterns that work well across all MultiOS programming languages.</p>
                    
                    <!-- Dependency Injection -->
                    <div class="pattern-section">
                        <h3>Dependency Injection</h3>
                        <p>Loose coupling through dependency injection makes code more testable and maintainable.</p>
                        
                        <div class="code-example">
                            <div class="code-header">
                                <span>Rust Implementation</span>
                                <button class="btn-copy" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                            <pre><code class="language-rust">use std::sync::Arc;

// Trait for file system operations
trait FileSystem {
    fn read_file(&self, path: &str) -> Result<String, std::io::Error>;
    fn write_file(&self, path: &str, content: &str) -> Result<(), std::io::Error>;
}

// Real implementation
struct RealFileSystem;

impl FileSystem for RealFileSystem {
    fn read_file(&self, path: &str) -> Result<String, std::io::Error> {
        std::fs::read_to_string(path)
    }
    
    fn write_file(&self, path: &str, content: &str) -> Result<(), std::io::Error> {
        std::fs::write(path, content)
    }
}

// Mock implementation for testing
struct MockFileSystem {
    files: std::collections::HashMap<String, String>,
}

impl FileSystem for MockFileSystem {
    fn read_file(&self, path: &str) -> Result<String, std::io::Error> {
        self.files.get(path)
            .cloned()
            .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::NotFound, "File not found"))
    }
    
    fn write_file(&self, path: &str, content: &str) -> Result<(), std::io::Error> {
        self.files.insert(path.to_string(), content.to_string());
        Ok(())
    }
}

// Service that depends on FileSystem
struct DataService<T: FileSystem> {
    filesystem: Arc<T>,
}

impl<T: FileSystem> DataService<T> {
    fn new(filesystem: Arc<T>) -> Self {
        Self { filesystem }
    }
    
    fn load_config(&self) -> Result<String, Box<dyn std::error::Error>> {
        let config = self.filesystem.read_file("/etc/app/config.json")?;
        Ok(config)
    }
    
    fn save_data(&self, data: &str) -> Result<(), Box<dyn std::error::Error>> {
        self.filesystem.write_file("/tmp/app/data.txt", data)?;
        Ok(())
    }
}

// Usage
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Production: use real file system
    let real_fs = Arc::new(RealFileSystem);
    let service = DataService::new(real_fs);
    let config = service.load_config()?;
    
    // Testing: use mock file system
    let mut mock_files = std::collections::HashMap::new();
    mock_files.insert("/etc/app/config.json".to_string(), 
                     r#"{"host": "localhost", "port": 8080}"#.to_string());
    
    let mock_fs = Arc::new(MockFileSystem { files: mock_files });
    let test_service = DataService::new(mock_fs);
    let test_config = test_service.load_config()?;
    
    println!("Config: {}", test_config);
    Ok(())
}</code></pre>
                        </div>
                        
                        <div class="code-example">
                            <div class="code-header">
                                <span>Python Implementation</span>
                                <button class="btn-copy" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                                </div>
                            <pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Dict, Any
import os

# Abstract interface
class FileSystem(ABC):
    @abstractmethod
    def read_file(self, path: str) -> str:
        pass
    
    @abstractmethod
    def write_file(self, path: str, content: str) -> None:
        pass

# Real implementation
class RealFileSystem(FileSystem):
    def read_file(self, path: str) -> str:
        with open(path, 'r') as f:
            return f.read()
    
    def write_file(self, path: str, content: str) -> None:
        with open(path, 'w') as f:
            f.write(content)

# Mock implementation for testing
class MockFileSystem(FileSystem):
    def __init__(self):
        self.files: Dict[str, str] = {}
    
    def read_file(self, path: str) -> str:
        if path not in self.files:
            raise FileNotFoundError(f"File {path} not found")
        return self.files[path]
    
    def write_file(self, path: str, content: str) -> None:
        self.files[path] = content

# Service that depends on FileSystem
class DataService:
    def __init__(self, filesystem: FileSystem):
        self.filesystem = filesystem
    
    def load_config(self) -> Dict[str, Any]:
        config_content = self.filesystem.read_file("/etc/app/config.json")
        # Parse JSON (simplified)
        import json
        return json.loads(config_content)
    
    def save_data(self, data: str) -> None:
        self.filesystem.write_file("/tmp/app/data.txt", data)

# Usage
def main():
    # Production: use real file system
    real_fs = RealFileSystem()
    service = DataService(real_fs)
    config = service.load_config()
    
    # Testing: use mock file system
    mock_fs = MockFileSystem()
    mock_fs.files["/etc/app/config.json"] = '{"host": "localhost", "port": 8080}'
    test_service = DataService(mock_fs)
    test_config = test_service.load_config()
    
    print(f"Config: {test_config}")

if __name__ == "__main__":
    main()</code></pre>
                        </div>
                    </div>

                    <!-- Factory Pattern -->
                    <div class="pattern-section">
                        <h3>Factory Pattern</h3>
                        <p>Centralized object creation with flexible configuration.</p>
                        
                        <div class="code-example">
                            <div class="code-header">
                                <span>Go Implementation</span>
                                <button class="btn-copy" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                                </div>
                            <pre><code class="language-go">package factory

import (
	"context"
	"fmt"
)

// Product interface
type Processor interface {
	Process(ctx context.Context, data []byte) ([]byte, error)
}

// Concrete products
type JSONProcessor struct {
	pretty bool
}

func (p *JSONProcessor) Process(ctx context.Context, data []byte) ([]byte, error) {
	// JSON processing logic
	return data, nil
}

type XMLProcessor struct {
	validate bool
}

func (p *XMLProcessor) Process(ctx context.Context, data []byte) ([]byte, error) {
	// XML processing logic
	return data, nil
}

type TextProcessor struct {
	encoding string
}

func (p *TextProcessor) Process(ctx context.Context, data []byte) ([]byte, error) {
	// Text processing logic
	return data, nil
}

// Factory struct
type ProcessorFactory struct {
	config map[string]interface{}
}

func NewProcessorFactory(config map[string]interface{}) *ProcessorFactory {
	return &ProcessorFactory{
		config: config,
	}
}

// CreateProcessor creates a processor based on type and configuration
func (f *ProcessorFactory) CreateProcessor(processorType string) (Processor, error) {
	switch processorType {
	case "json":
		return &JSONProcessor{
			pretty: f.config["json_pretty"].(bool),
		}, nil
		
	case "xml":
		return &XMLProcessor{
			validate: f.config["xml_validate"].(bool),
		}, nil
		
	case "text":
		return &TextProcessor{
			encoding: f.config["text_encoding"].(string),
		}, nil
		
	default:
		return nil, fmt.Errorf("unsupported processor type: %s", processorType)
	}
}

// Builder pattern for complex configuration
type ProcessorBuilder struct {
	processorType string
	config        map[string]interface{}
}

func NewProcessorBuilder() *ProcessorBuilder {
	return &ProcessorBuilder{
		config: make(map[string]interface{}),
	}
}

func (b *ProcessorBuilder) WithType(processorType string) *ProcessorBuilder {
	b.processorType = processorType
	return b
}

func (b *ProcessorBuilder) WithConfig(key string, value interface{}) *ProcessorBuilder {
	b.config[key] = value
	return b
}

func (b *ProcessorBuilder) WithJSONPretty(pretty bool) *ProcessorBuilder {
	b.config["json_pretty"] = pretty
	return b
}

func (b *ProcessorBuilder) WithXMLValidation(validate bool) *ProcessorBuilder {
	b.config["xml_validate"] = validate
	return b
}

func (b *ProcessorBuilder) WithTextEncoding(encoding string) *ProcessorBuilder {
	b.config["text_encoding"] = encoding
	return b
}

func (b *ProcessorBuilder) Build() (Processor, error) {
	factory := NewProcessorFactory(b.config)
	return factory.CreateProcessor(b.processorType)
}

// Usage example
func demonstrateFactory() {
	// Using builder pattern
	builder := NewProcessorBuilder()
	
	processor, err := builder.
		WithType("json").
		WithJSONPretty(true).
		Build()
	
	if err != nil {
		fmt.Printf("Failed to create processor: %v\n", err)
		return
	}
	
	// Use the processor
	ctx := context.Background()
	result, err := processor.Process(ctx, []byte(`{"test": "data"}`))
	if err != nil {
		fmt.Printf("Processing failed: %v\n", err)
		return
	}
	
	fmt.Printf("Processing result: %s\n", result)
}</code></pre>
                        </div>
                    </div>

                    <!-- Observer Pattern -->
                    <div class="pattern-section">
                        <h3>Observer Pattern</h3>
                        <p>Event-driven communication between components.</p>
                        
                        <div class="code-example">
                            <div class="code-header">
                                <span>C++ Implementation</span>
                                <button class="btn-copy" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i>
                                </button>
                                </div>
                            <pre><code class="language-cpp">#include <functional>
#include <vector>
#include <memory>
#include <algorithm>
#include <iostream>

// Event data structure
template<typename T>
struct Event {
    T data;
    std::chrono::system_clock::time_point timestamp;
    
    Event(const T& data) : data(data), timestamp(std::chrono::system_clock::now()) {}
};

// Observer interface
template<typename T>
class Observer {
public:
    virtual ~Observer() = default;
    virtual void onEvent(const Event<T>& event) = 0;
};

// Subject/Observable
template<typename T>
class Subject {
private:
    std::vector<std::weak_ptr<Observer<T>>> observers_;
    mutable std::mutex mutex_;

public:
    void attach(std::shared_ptr<Observer<T>> observer) {
        std::lock_guard<std::mutex> lock(mutex_);
        observers_.push_back(observer);
    }

    void detach(std::shared_ptr<Observer<T>> observer) {
        std::lock_guard<std::mutex> lock(mutex_);
        observers_.erase(
            std::remove_if(observers_.begin(), observers_.end(),
                [&observer](const std::weak_ptr<Observer<T>>& weak_obs) {
                    auto obs = weak_obs.lock();
                    return !obs || obs.get() == observer.get();
                }),
            observers_.end()
        );
    }

    void notify(const T& data) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        Event<T> event(data);
        
        // Remove expired observers and notify active ones
        auto new_end = std::remove_if(observers_.begin(), observers_.end(),
            [&event](const std::weak_ptr<Observer<T>>& weak_obs) {
                if (auto obs = weak_obs.lock()) {
                    obs->onEvent(event);
                    return false;
                }
                return true; // Remove expired observer
            });
        
        observers_.erase(new_end, observers_.end());
    }

    void clear() {
        std::lock_guard<std::mutex> lock(mutex_);
        observers_.clear();
    }
};

// Concrete observer
class DataProcessor : public Observer<std::string> {
private:
    std::string name_;

public:
    explicit DataProcessor(const std::string& name) : name_(name) {}

    void onEvent(const Event<std::string>& event) override {
        std::cout << "[" << name_ << "] Received: " << event.data 
                  << " at " << std::chrono::duration_cast<std::chrono::milliseconds>(
                      event.timestamp.time_since_epoch()).count() << "ms\n";
    }
};

// Usage example
void demonstrateObserver() {
    Subject<std::string> dataSubject;
    
    // Create observers
    auto processor1 = std::make_shared<DataProcessor>("Processor1");
    auto processor2 = std::make_shared<DataProcessor>("Processor2");
    
    // Attach observers
    dataSubject.attach(processor1);
    dataSubject.attach(processor2);
    
    // Send events
    dataSubject.notify("Hello, World!");
    dataSubject.notify("Processing data...");
    
    // Detach an observer
    dataSubject.detach(processor1);
    
    // Send more events
    dataSubject.notify("Final event");
    
    // Cleanup
    dataSubject.clear();
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Performance Guidelines -->
                <section class="content-section">
                    <h2>Performance Guidelines</h2>
                    
                    <div class="performance-tips">
                        <div class="tip-card">
                            <div class="tip-icon">
                                <i class="fas fa-memory"></i>
                            </div>
                            <div class="tip-content">
                                <h4>Memory Management</h4>
                                <ul>
                                    <li>Pre-allocate collections when size is known</li>
                                    <li>Use memory pools for frequent small allocations</li>
                                    <li>Implement proper cleanup to prevent memory leaks</li>
                                    <li>Monitor memory usage in production</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="tip-card">
                            <div class="tip-icon">
                                <i class="fas fa-tachometer-alt"></i>
                            </div>
                            <div class="tip-content">
                                <h4>CPU Optimization</h4>
                                <ul>
                                    <li>Profile code to identify bottlenecks</li>
                                    <li>Use appropriate algorithms and data structures</li>
                                    <li>Implement caching for expensive computations</li>
                                    <li>Consider parallelization where applicable</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="tip-card">
                            <div class="tip-icon">
                                <i class="fas fa-network-wired"></i>
                            </div>
                            <div class="tip-content">
                                <h4>I/O Operations</h4>
                                <ul>
                                    <li>Use buffered I/O for better performance</li>
                                    <li>Implement connection pooling for network operations</li>
                                    <li>Batch operations when possible</li>
                                    <li>Use asynchronous I/O for responsiveness</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="tip-card">
                            <div class="tip-icon">
                                <i class="fas fa-database"></i>
                            </div>
                            <div class="tip-content">
                                <h4>Database Operations</h4>
                                <ul>
                                    <li>Use prepared statements</li>
                                    <li>Implement connection pooling</li>
                                    <li>Optimize queries and use indexes</li>
                                    <li>Consider read replicas for read-heavy workloads</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Security Best Practices -->
                <section class="content-section">
                    <h2>Security Best Practices</h2>
                    
                    <div class="security-guidelines">
                        <div class="security-section">
                            <h3>Input Validation</h3>
                            <ul>
                                <li>Always validate and sanitize user input</li>
                                <li>Use parameterized queries to prevent SQL injection</li>
                                <li>Validate file paths to prevent directory traversal</li>
                                <li>Implement rate limiting to prevent DoS attacks</li>
                            </ul>
                        </div>
                        
                        <div class="security-section">
                            <h3>Authentication & Authorization</h3>
                            <ul>
                                <li>Use strong password hashing (bcrypt, Argon2)</li>
                                <li>Implement proper session management</li>
                                <li>Use principle of least privilege</li>
                                <li>Implement proper access controls</li>
                            </ul>
                        </div>
                        
                        <div class="security-section">
                            <h3>Cryptography</h3>
                            <ul>
                                <li>Use established cryptographic libraries</li>
                                <li>Never implement your own crypto</li>
                                <li>Use TLS for all network communications</li>
                                <li>Protect sensitive data at rest and in transit</li>
                            </ul>
                        </div>
                        
                        <div class="security-section">
                            <h3>Error Handling</h3>
                            <ul>
                                <li>Don't expose sensitive information in error messages</li>
                                <li>Log security events for monitoring</li>
                                <li>Implement proper error responses</li>
                                <li>Use generic error messages for authentication failures</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Testing Guidelines -->
                <section class="content-section">
                    <h2>Testing Guidelines</h2>
                    
                    <div class="testing-pyramid">
                        <div class="pyramid-level">
                            <h4>Unit Tests (70%)</h4>
                            <p>Test individual functions and methods in isolation</p>
                            <ul>
                                <li>Test all edge cases and error conditions</li>
                                <li>Use mocks and stubs for dependencies</li>
                                <li>Achieve high code coverage</li>
                                <li>Run tests in isolation</li>
                            </ul>
                        </div>
                        
                        <div class="pyramid-level">
                            <h4>Integration Tests (20%)</h4>
                            <p>Test component interactions and system integration</p>
                            <ul>
                                <li>Test API endpoints with real dependencies</li>
                                <li>Test database operations</li>
                                <li>Test network communication</li>
                                <li>Verify system behavior end-to-end</li>
                            </ul>
                        </div>
                        
                        <div class="pyramid-level">
                            <h4>End-to-End Tests (10%)</h4>
                            <p>Test complete user workflows and system behavior</p>
                            <ul>
                                <li>Test critical user journeys</li>
                                <li>Use real browser automation</li>
                                <li>Test cross-browser compatibility</li>
                                <li>Keep tests minimal and focused</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Deployment and DevOps -->
                <section class="content-section">
                    <h2>Deployment and DevOps</h2>
                    
                    <div class="devops-section">
                        <div class="devops-item">
                            <h3>Build and Compilation</h3>
                            <ul>
                                <li>Use reproducible builds</li>
                                <li>Enable compiler optimizations for production</li>
                                <li>Strip debug symbols from production binaries</li>
                                <li>Create multi-architecture builds when needed</li>
                            </ul>
                        </div>
                        
                        <div class="devops-item">
                            <h3>Environment Management</h3>
                            <ul>
                                <li>Separate development, staging, and production environments</li>
                                <li>Use environment variables for configuration</li>
                                <li>Implement proper secrets management</li>
                                <li>Use configuration management tools</li>
                            </ul>
                        </div>
                        
                        <div class="devops-item">
                            <h3>Monitoring and Logging</h3>
                            <ul>
                                <li>Implement comprehensive logging</li>
                                <li>Set up health checks and metrics</li>
                                <li>Monitor application performance</li>
                                <li>Use distributed tracing for microservices</li>
                            </ul>
                        </div>
                        
                        <div class="devops-item">
                            <h3>CI/CD Pipeline</h3>
                            <ul>
                                <li>Automate testing in CI pipeline</li>
                                <li>Use automated security scanning</li>
                                <li>Implement blue-green or canary deployments</li>
                                <li>Have rollback procedures ready</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Conclusion -->
                <section class="content-section">
                    <h2>Summary</h2>
                    <p>These best practices provide a foundation for building robust, maintainable, and performant applications on MultiOS. Key takeaways:</p>
                    
                    <ul>
                        <li><strong>Memory Safety:</strong> Always manage memory properly and validate all allocations</li>
                        <li><strong>Error Handling:</strong> Implement comprehensive error handling at all levels</li>
                        <li><strong>Performance:</strong> Design with performance in mind and profile critical paths</li>
                        <li><strong>Security:</strong> Follow security best practices from the beginning</li>
                        <li><strong>Testing:</strong> Write comprehensive tests to ensure reliability</li>
                        <li><strong>Documentation:</strong> Document code thoroughly for maintainability</li>
                        <li><strong>Monitoring:</strong> Implement proper logging and monitoring in production</li>
                    </ul>
                    
                    <div class="next-steps">
                        <h3>Next Steps</h3>
                        <ul>
                            <li>Review language-specific guides: <a href="integration/rust.html">Rust</a>, <a href="integration/python.html">Python</a>, <a href="integration/javascript.html">JavaScript</a>, etc.</li>
                            <li>Explore the <a href="../../api_reference/index.html">API Reference</a> for detailed function documentation</li>
                            <li>Try hands-on examples in the <a href="../../tutorials/index.html">Tutorials</a></li>
                            <li>Use the <a href="../../api-explorer.html">API Explorer</a> for interactive testing</li>
                        </ul>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/search.js"></script>
    <script src="../../assets/js/theme.js"></script>
    <script src="../../assets/js/interactive.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <style>
        .principle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .principle-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }

        .principle-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }

        .principle-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary-color), #6366f1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .principle-icon i {
            font-size: 24px;
            color: white;
        }

        .principle-content h3 {
            margin: 0 0 12px 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .principle-content p {
            margin: 0;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .language-section {
            margin: 30px 0;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .language-section h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 20px;
        }

        .practice-item {
            margin: 20px 0;
        }

        .practice-item h4 {
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .code-example {
            margin: 16px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .pattern-section {
            margin: 30px 0;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .performance-tips {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .tip-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid var(--primary-color);
        }

        .tip-icon {
            color: var(--primary-color);
            font-size: 24px;
            margin-bottom: 12px;
        }

        .tip-content h4 {
            margin: 0 0 12px 0;
            color: var(--text-primary);
        }

        .tip-content ul {
            margin: 0;
            padding-left: 20px;
        }

        .tip-content li {
            margin: 8px 0;
            color: var(--text-secondary);
        }

        .security-guidelines {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .security-section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .security-section h3 {
            color: var(--text-primary);
            margin: 0 0 16px 0;
            font-size: 18px;
        }

        .security-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .security-section li {
            margin: 8px 0;
            color: var(--text-secondary);
        }

        .testing-pyramid {
            margin: 20px 0;
        }

        .pyramid-level {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin: 12px 0;
            border-left: 4px solid var(--primary-color);
        }

        .pyramid-level h4 {
            margin: 0 0 12px 0;
            color: var(--text-primary);
        }

        .pyramid-level p {
            margin: 0 0 12px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .pyramid-level ul {
            margin: 0;
            padding-left: 20px;
        }

        .pyramid-level li {
            margin: 6px 0;
            color: var(--text-secondary);
        }

        .devops-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .devops-item {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .devops-item h3 {
            margin: 0 0 16px 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .devops-item ul {
            margin: 0;
            padding-left: 20px;
        }

        .devops-item li {
            margin: 8px 0;
            color: var(--text-secondary);
        }

        .next-steps {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .next-steps h3 {
            margin: 0 0 12px 0;
            color: var(--text-primary);
        }

        .next-steps ul {
            margin: 0;
            padding-left: 20px;
        }

        .next-steps li {
            margin: 8px 0;
        }

        .next-steps a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .next-steps a:hover {
            text-decoration: underline;
        }
    </style>
</body>
</html>